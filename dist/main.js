"use strict";var pe=Object.defineProperty,we=Object.defineProperties;var me=Object.getOwnPropertyDescriptors;var te=Object.getOwnPropertySymbols;var Ie=Object.prototype.hasOwnProperty,Ne=Object.prototype.propertyIsEnumerable;var Q=(e,t,n)=>t in e?pe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,q=(e,t)=>{for(var n in t||(t={}))Ie.call(t,n)&&Q(e,n,t[n]);if(te)for(var n of te(t))Ne.call(t,n)&&Q(e,n,t[n]);return e},G=(e,t)=>we(e,me(t));var U=(e,t,n)=>Q(e,typeof t!="symbol"?t+"":t,n);function Ee(e,t){const n=`ws://localhost:${e}`,r=new ve(n);return{connect:()=>r.connect(t),disconnect:()=>r.disconnect(),isConnected:()=>r.isConnected(),onMessage:null,onConnectionChange:null,setMessageHandler:o=>{r.onCommand(o)}}}class ve{constructor(t){U(this,"ws",null);U(this,"reconnectInterval",5e3);U(this,"maxReconnectInterval",3e4);U(this,"reconnectDecay",1.5);U(this,"reconnectAttempts",0);U(this,"url");U(this,"channelId",null);U(this,"serverId",null);U(this,"messageHandlers",new Map);this.url=t}connect(t){t&&(this.channelId=t);try{this.ws=new WebSocket(this.url),this.ws.onopen=()=>{console.log("WebSocket connected"),this.reconnectAttempts=0,this.send({type:"register",channelId:this.channelId}),setInterval(()=>{var n;((n=this.ws)==null?void 0:n.readyState)===WebSocket.OPEN&&this.send({type:"ping"})},3e4)},this.ws.onmessage=n=>{try{const r=JSON.parse(n.data);this.handleMessage(r)}catch(r){console.error("Failed to parse WebSocket message:",r)}},this.ws.onclose=()=>{console.log("WebSocket disconnected"),this.reconnect()},this.ws.onerror=n=>{console.error("WebSocket error:",n)}}catch(n){this.reconnect()}}handleMessage(t){switch(t.type){case"channel_assigned":this.channelId=t.channelId,this.serverId=t.serverId,console.log(`Connected to channel: ${this.channelId}`);break;case"command":const n=this.messageHandlers.get("command");n&&n(t);break;case"pong":break;default:console.log("Unknown message type:",t.type)}}onCommand(t){this.messageHandlers.set("command",t)}send(t){var n;((n=this.ws)==null?void 0:n.readyState)===WebSocket.OPEN?this.ws.send(JSON.stringify(t)):console.warn("WebSocket not connected")}reconnect(){if(this.reconnectAttempts>=10){console.error("Max reconnection attempts reached");return}const t=Math.min(this.reconnectInterval*Math.pow(this.reconnectDecay,this.reconnectAttempts),this.maxReconnectInterval);this.reconnectAttempts++,setTimeout(()=>{this.connect()},t)}disconnect(){this.ws&&(this.ws.close(),this.ws=null)}getChannelId(){return this.channelId}getServerId(){return this.serverId}isConnected(){var t;return((t=this.ws)==null?void 0:t.readyState)===WebSocket.OPEN}}function ie(e){const t=e.replace("#","");if(t.length===3){const n=parseInt(t[0]+t[0],16)/255,r=parseInt(t[1]+t[1],16)/255,o=parseInt(t[2]+t[2],16)/255;return{r:n,g:r,b:o,a:1}}else if(t.length===6){const n=parseInt(t.substring(0,2),16)/255,r=parseInt(t.substring(2,4),16)/255,o=parseInt(t.substring(4,6),16)/255;return{r:n,g:r,b:o,a:1}}else if(t.length===8){const n=parseInt(t.substring(0,2),16)/255,r=parseInt(t.substring(2,4),16)/255,o=parseInt(t.substring(4,6),16)/255,s=parseInt(t.substring(6,8),16)/255;return{r:n,g:r,b:o,a:s}}return{r:0,g:0,b:0,a:1}}function B(e){if(e.startsWith("#"))return ie(e);if(e.startsWith("rgba(")){const n=e.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);if(n)return{r:parseInt(n[1])/255,g:parseInt(n[2])/255,b:parseInt(n[3])/255,a:parseFloat(n[4])}}if(e.startsWith("rgb(")){const n=e.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);if(n)return{r:parseInt(n[1])/255,g:parseInt(n[2])/255,b:parseInt(n[3])/255,a:1}}const t={white:{r:1,g:1,b:1,a:1},black:{r:0,g:0,b:0,a:1},red:{r:1,g:0,b:0,a:1},green:{r:0,g:1,b:0,a:1},blue:{r:0,g:0,b:1,a:1},yellow:{r:1,g:1,b:0,a:1},cyan:{r:0,g:1,b:1,a:1},magenta:{r:1,g:0,b:1,a:1},transparent:{r:0,g:0,b:0,a:0}};return t[e.toLowerCase()]?t[e.toLowerCase()]:{r:0,g:0,b:0,a:1}}function S(e){if(typeof e=="string"){const t=B(e);return{type:"SOLID",color:{r:t.r,g:t.g,b:t.b},opacity:t.a!==void 0?t.a:1}}return{type:"SOLID",color:{r:e.r||0,g:e.g||0,b:e.b||0},opacity:e.a!==void 0?e.a:1}}function W(e,t){if(t)return t;const r=figma.currentPage.findAll().filter(o=>o.name.startsWith(e));return`${e} ${r.length+1}`}async function O(e,t){if(t)try{const n=await figma.getNodeByIdAsync(t);if(!n)throw new Error(`Parent node not found with ID: ${t}`);if(!("appendChild"in n))throw new Error(`Parent node does not support children: ${t}`);return n.appendChild(e),t}catch(n){return console.warn("Failed to add to parent, adding to current page:",n.message),figma.currentPage.appendChild(e),null}else return figma.currentPage.appendChild(e),null}function Z(e,t){var n,r,o,s;if(!(!t||typeof t!="object")&&t.addDropShadow){const i={type:"DROP_SHADOW",color:{r:((n=t.shadowColor)==null?void 0:n.r)||0,g:((r=t.shadowColor)==null?void 0:r.g)||0,b:((o=t.shadowColor)==null?void 0:o.b)||0,a:((s=t.shadowColor)==null?void 0:s.a)||.25},offset:{x:t.shadowOffsetX||0,y:t.shadowOffsetY||4},radius:t.shadowRadius||4,spread:t.shadowSpread||0,visible:!0,blendMode:"NORMAL"};e.effects=[i]}}function F(e,t){return{success:!0,nodeId:e.id,id:e.id,name:e.name,type:e.type,x:"x"in e?e.x:0,y:"y"in e?e.y:0,width:"width"in e?e.width:0,height:"height"in e?e.height:0,parentId:t||null}}function H(e){return e&&"x"in e&&"y"in e&&"width"in e&&"height"in e&&"appendChild"in e.parent}function ee(e){return e.replace(/-/g,":")}async function v(e){const t=ee(e);return await figma.getNodeByIdAsync(t)}async function be(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,s=W("Ellipse",e.name),i=e.initialOpacity!==void 0?Number(e.initialOpacity):1,c=e.initialRotation!==void 0?Number(e.initialRotation):0,d=e.parentIdForNode||e.parentId||null,l=e.startingAngle!==void 0?Number(e.startingAngle):0,a=e.endingAngle!==void 0?Number(e.endingAngle):0,h=e.innerRadius!==void 0?Number(e.innerRadius):0,f=figma.createEllipse();if(f.x=t,f.y=n,f.resize(r,o),f.name=s,f.opacity=i,f.rotation=c,(l!==0||a!==0||h!==0)&&(f.arcData={startingAngle:l,endingAngle:a,innerRadius:h}),e.fillColor||e.Fill_Color_R!==void 0){const u=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};f.fills=[S(u)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const u=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};f.strokes=[S(u)],f.strokeWeight=e.strokeWeight!==void 0?Number(e.strokeWeight):1}e.addDropShadow&&(f.effects=[Z()]);const g=await O(f,d);return figma.currentPage.selection=[f],figma.viewport.scrollAndZoomIntoView([f]),F(f,g)}async function _e(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,s=W("Rectangle",e.name),i=e.cornerRadius!==void 0?Number(e.cornerRadius):0,c=e.initialOpacity!==void 0?Number(e.initialOpacity):1,d=e.initialRotation!==void 0?Number(e.initialRotation):0,l=e.parentIdForNode||e.parentId||null,a=figma.createRectangle();if(a.x=t,a.y=n,a.resize(r,o),a.name=s,a.opacity=c,a.rotation=d,i>0&&(a.cornerRadius=i),e.fillColor||e.Fill_Color_R!==void 0){const f=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};a.fills=[S(f)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const f=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};a.strokes=[S(f)],a.strokeWeight=e.strokeWeight||1}Z(a,e);const h=await O(a,l);return figma.currentPage.selection=[a],F(a,h)}async function xe(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.radius!==void 0?Number(e.radius):50,o=W("Circle",e.name),s=e.initialOpacity!==void 0?Number(e.initialOpacity):1,i=e.initialRotation!==void 0?Number(e.initialRotation):0,c=e.parentIdForNode||e.parentId||null,d=figma.createEllipse();if(d.x=t,d.y=n,d.resize(r*2,r*2),d.name=o,d.opacity=s,d.rotation=i,e.fillColor||e.Fill_Color_R!==void 0){const a=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};d.fills=[S(a)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const a=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};d.strokes=[S(a)],d.strokeWeight=e.strokeWeight||1}Z(d,e);const l=await O(d,c);return figma.currentPage.selection=[d],F(d,l)}async function Ce(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x1!==void 0?Number(e.x1):0,n=e.y1!==void 0?Number(e.y1):0,r=e.x2!==void 0?Number(e.x2):100,o=e.y2!==void 0?Number(e.y2):100,s=W("Line",e.name),i=e.parentIdForNode||e.parentId||null,c=Math.min(t,r),d=Math.min(n,o),l=Math.abs(r-t)||1,a=Math.abs(o-n)||1,h=figma.createLine();h.x=c,h.y=d,h.resize(l,a),h.name=s;const f=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};h.strokes=[S(f)],h.strokeWeight=e.strokeWeight||e.Stroke_Weight||1,Z(h,e);const g=await O(h,i);return figma.currentPage.selection=[h],F(h,g)}async function Ae(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,s=e.points!==void 0?Number(e.points):5,i=e.innerRadiusRatio!==void 0?Number(e.innerRadiusRatio):.5,c=W("Star",e.name),d=e.parentIdForNode||e.parentId||null,l=figma.createStar();if(l.x=t,l.y=n,l.resize(r,o),l.name=c,l.pointCount=s,l.innerRadius=i,e.fillColor||e.Fill_Color_R!==void 0){const h=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};l.fills=[S(h)]}Z(l,e);const a=await O(l,d);return figma.currentPage.selection=[l],F(l,a)}async function Se(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,s=e.sides!==void 0?Number(e.sides):6,i=W("Polygon",e.name),c=e.parentIdForNode||e.parentId||null,d=figma.createPolygon();if(d.x=t,d.y=n,d.resize(r,o),d.name=i,d.pointCount=Math.max(3,s),e.fillColor||e.Fill_Color_R!==void 0){const a=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};d.fills=[S(a)]}Z(d,e);const l=await O(d,c);return figma.currentPage.selection=[d],F(d,l)}async function Pe(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.pathData||e.Path_Data||e.path,o=W("Vector",e.name),s=e.parentIdForNode||e.parentId||null;if(!r)throw new Error("Path data is required for vector path creation");try{const i=figma.createVector();if(i.x=t,i.y=n,i.name=o,i.vectorPaths=[{windingRule:"NONZERO",data:r}],e.fillColor||e.Fill_Color_R!==void 0){const d=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};i.fills=[S(d)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const d=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};i.strokes=[S(d)],i.strokeWeight=e.strokeWeight!==void 0?Number(e.strokeWeight):1}Z(i,e);const c=await O(i,s);return figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),G(q({},F(i,c)),{pathData:r})}catch(i){throw console.error("Error creating vector path:",i),new Error(`Failed to create vector path: ${i.message||i}`)}}function se(e){const t=typeof e=="string"?parseInt(e):e;return!t||t===400?"Regular":t>=900?"Black":t>=800?"Extra Bold":t>=700?"Bold":t>=600?"Semi Bold":t>=500?"Medium":t>=300?"Light":t>=200?"Extra Light":t>=100?"Thin":"Regular"}async function De(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.textContent||e.text||e.Text_Content||"Hello World",n=e.x!==void 0?Number(e.x):0,r=e.y!==void 0?Number(e.y):0,o=e.fontSize!==void 0?Number(e.fontSize):16,s=e.fontFamily||e.Font_Family||"Inter",i=e.fontWeight||e.Font_Weight;let c=e.textColor||e.Text_Color||e.fontColor||e.Font_Color;!c&&(e.Font_Color_R!==void 0||e.Font_Color_G!==void 0||e.Font_Color_B!==void 0)&&(c={r:e.Font_Color_R!==void 0?e.Font_Color_R:0,g:e.Font_Color_G!==void 0?e.Font_Color_G:0,b:e.Font_Color_B!==void 0?e.Font_Color_B:0,a:e.Font_Color_A!==void 0?e.Font_Color_A:1}),c||(c={r:0,g:0,b:0,a:1});const d=e.backgroundColor||e.Background_Color,l=e.textAlign||e.Text_Align||e.textAlignHorizontal||"LEFT",a=e.letterSpacing||e.Letter_Spacing,h=e.lineHeight||e.Line_Height,f=W("Text",e.name),g=e.parentIdForNode||e.parentId||null;try{const u=figma.createText();u.x=n,u.y=r,u.name=f;const m=se(i);try{await figma.loadFontAsync({family:s,style:m}),u.fontName={family:s,style:m}}catch(w){console.warn(`Failed to load font ${s} ${m}, falling back to Inter Regular`),await figma.loadFontAsync({family:"Inter",style:"Regular"}),u.fontName={family:"Inter",style:"Regular"}}if(u.fontSize=o,u.characters=t,c){const w=typeof c=="string"?B(c):c;u.fills=[S(w)]}if(d){const w=typeof d=="string"?B(d):d,p=figma.createFrame();p.x=n,p.y=r,p.resize(u.width+20,u.height+10),p.fills=[S(w)],p.name=`${f} Background`,u.x=10,u.y=5,p.appendChild(u);const I=await O(p,g);return figma.currentPage.selection=[p],G(q({},F(p,I)),{textNodeId:u.id})}l&&(u.textAlignHorizontal=l),a!==void 0&&(u.letterSpacing={value:Number(a),unit:"PIXELS"}),h!==void 0&&(u.lineHeight={value:Number(h),unit:"PIXELS"});const y=await O(u,g);return figma.currentPage.selection=[u],F(u,y)}catch(u){throw console.error("Error creating text:",u),new Error(`Failed to create text: ${u.message||u}`)}}async function ce(e){const t=e.nodeId||e.Node_ID,n=e.newContent||e.New_Content||e.textContent;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("New content is required");try{const r=await v(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(r.type!=="TEXT")throw new Error(`Node ${t} is not a text node (type: ${r.type})`);const o=r;return await figma.loadFontAsync(o.fontName),o.characters=String(n),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,characters:o.characters,previousContent:e.previousContent}}catch(r){throw console.error("Error updating text content:",r),new Error(`Failed to update text content: ${r.message||r}`)}}async function ke(e){return await ce(e)}async function Te(e){const t=e.nodeId||e.Node_ID,n=e.fontFamily||e.Font_Family||"Inter",r=e.fontWeight||e.Font_Weight||400,o=e.fontSize||e.Font_Size;if(!t)throw new Error("Node ID is required");try{const s=await v(t);if(!s)throw new Error(`Node not found with ID: ${t}`);if(s.type!=="TEXT")throw new Error(`Node ${t} is not a text node (type: ${s.type})`);const i=s,c=se(r);return await figma.loadFontAsync({family:n,style:c}),i.fontName={family:n,style:c},o&&(i.fontSize=Number(o)),figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),{success:!0,nodeId:i.id,name:i.name,type:i.type,fontName:i.fontName,fontSize:i.fontSize}}catch(s){throw console.error("Error setting font:",s),new Error(`Failed to set font: ${s.message||s}`)}}async function Oe(e){const t=e.containsText||e.Contains_Text||e.searchText,n=e.parentId||e.Parent_ID;try{let r=function(c){if(c.type==="TEXT"){const d=c;(!t||d.characters.toLowerCase().includes(t.toLowerCase()))&&s.push(d)}if("children"in c)for(const d of c.children)r(d)},o;if(n){const c=await v(n);if(!c)throw new Error(`Parent node not found with ID: ${n}`);o=c}else o=figma.currentPage;const s=[];r(o);const i=s.map(c=>({nodeId:c.id,name:c.name,text:c.characters,fontSize:c.fontSize===figma.mixed?"mixed":c.fontSize,fontName:c.fontName===figma.mixed?"mixed":c.fontName,x:c.x,y:c.y,width:c.width,height:c.height}));return{success:!0,textNodes:i,count:i.length,searchCriteria:t||"all text nodes"}}catch(r){throw console.error("Error scanning text nodes:",r),new Error(`Failed to scan text nodes: ${r.message||r}`)}}async function Fe(e){let t=e.updates||e.Updates||e.textUpdates||[];if(!Array.isArray(t)||t.length===0)throw new Error("Updates array is required with nodeId and text pairs");try{const n=[];for(const o of t){const s=o.nodeId||o.Node_ID,i=o.text||o.Text||o.content;if(!s){n.push({nodeId:"unknown",name:"unknown",success:!1,error:"Node ID is required"});continue}try{const c=await v(s);if(!c){n.push({nodeId:s,name:"not found",success:!1,error:"Node not found"});continue}if(c.type!=="TEXT"){n.push({nodeId:s,name:c.name,success:!1,error:`Node is not a text node (type: ${c.type})`});continue}const d=c;d.fontName!==figma.mixed?await figma.loadFontAsync(d.fontName):(await figma.loadFontAsync({family:"Inter",style:"Regular"}),d.fontName={family:"Inter",style:"Regular"}),d.characters=i||"",n.push({nodeId:c.id,name:c.name,success:!0})}catch(c){n.push({nodeId:s,name:"unknown",success:!1,error:c.message||"Unknown error"})}}const r=n.filter(o=>o.success).length;return{success:!0,results:n,totalRequested:t.length,successCount:r,failureCount:t.length-r}}catch(n){throw console.error("Error setting multiple text contents:",n),new Error(`Failed to set multiple text contents: ${n.message||n}`)}}async function Me(e){try{const t=e.keyword||e.Keyword||e.query||e.searchQuery||e.Search_Query||"",n=await figma.listAvailableFontsAsync();let r=n;if(t){const i=t.toLowerCase();r=n.filter(c=>c.fontName.family.toLowerCase().includes(i)||c.fontName.style.toLowerCase().includes(i))}const o=r.map(i=>({family:i.fontName.family,style:i.fontName.style,fullName:`${i.fontName.family} ${i.fontName.style}`})),s=r.reduce((i,c)=>{const d=c.fontName.family;return i[d]||(i[d]=[]),i[d].push(c.fontName.style),i},{});return{success:!0,fonts:o,fontsByFamily:s,totalCount:r.length,searchQuery:t||"all fonts",availableFamilies:Object.keys(s).sort()}}catch(t){throw console.error("Error searching available fonts:",t),new Error(`Failed to search available fonts: ${t.message||t}`)}}async function $e(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required for setFillColor");let n=e.color||e.Color;if(!n&&(e.r!==void 0||e.R!==void 0)&&(n={r:e.r!==void 0?e.r:e.R||0,g:e.g!==void 0?e.g:e.G||0,b:e.b!==void 0?e.b:e.B||0,a:e.a!==void 0?e.a:e.A!==void 0?e.A:1}),!n)throw new Error("Color is required");try{const r=await v(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("fills"in r))throw new Error(`Node ${t} does not support fills`);const o=r,s=S(n);return o.fills=[s],figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,color:s.color,opacity:s.opacity}}catch(r){throw console.error("Error setting fill color:",r),new Error(`Failed to set fill color: ${r.message||r}`)}}async function Re(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required for setStrokeColor");let n=e.color||e.Color;const r=e.strokeWeight||e.Stroke_Weight||1;if(!n&&(e.r!==void 0||e.R!==void 0)&&(n={r:e.r!==void 0?e.r:e.R||0,g:e.g!==void 0?e.g:e.G||0,b:e.b!==void 0?e.b:e.B||0,a:e.a!==void 0?e.a:e.A!==void 0?e.A:1}),!n)throw new Error("Color is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("strokes"in o))throw new Error(`Node ${t} does not support strokes`);const s=o,i=S(n);return s.strokes=[i],s.strokeWeight=Number(r),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,color:i.color,opacity:i.opacity,strokeWeight:s.strokeWeight}}catch(o){throw console.error("Error setting stroke color:",o),new Error(`Failed to set stroke color: ${o.message||o}`)}}async function Le(e){const t=e.nodeId||e.Node_ID,n=e.opacity!==void 0?e.opacity:e.Opacity;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("Opacity value is required");const r=Number(n);if(isNaN(r)||r<0||r>1)throw new Error("Opacity must be a number between 0 and 1");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("opacity"in o))throw new Error(`Node ${t} does not support opacity`);const s=o;return s.opacity=r,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,opacity:s.opacity}}catch(o){throw console.error("Error setting opacity:",o),new Error(`Failed to set opacity: ${o.message||o}`)}}async function Ve(e){const t=e.nodeId||e.Node_ID,n=e.effectType||e.Effect_Type;if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Effect type is required");try{const r=await v(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("effects"in r))throw new Error(`Node ${t} does not support effects`);const o=r;let s;switch(n.toUpperCase()){case"DROP_SHADOW":s={type:"DROP_SHADOW",color:e.color?B(e.color):{r:0,g:0,b:0,a:.25},offset:{x:e.offsetX||0,y:e.offsetY||4},radius:e.radius||4,spread:e.spread||0,visible:!0,blendMode:"NORMAL"};break;case"INNER_SHADOW":s={type:"INNER_SHADOW",color:e.color?B(e.color):{r:0,g:0,b:0,a:.25},offset:{x:e.offsetX||0,y:e.offsetY||4},radius:e.radius||4,spread:e.spread||0,visible:!0,blendMode:"NORMAL"};break;case"LAYER_BLUR":s={type:"LAYER_BLUR",radius:e.radius||4,visible:!0};break;case"BACKGROUND_BLUR":s={type:"BACKGROUND_BLUR",radius:e.radius||4,visible:!0};break;default:throw new Error(`Unsupported effect type: ${n}`)}return o.effects=[...o.effects,s],figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,effectType:n,effectsCount:o.effects.length}}catch(r){throw console.error("Error applying effect:",r),new Error(`Failed to apply effect: ${r.message||r}`)}}async function ze(e){const t=e.nodeId||e.Node_ID,n=e.radius!==void 0?e.radius:e.Radius;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("Radius value is required");const r=Number(n);if(isNaN(r)||r<0)throw new Error("Radius must be a non-negative number");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("cornerRadius"in o))throw new Error(`Node ${t} does not support corner radius`);const s=o;return s.cornerRadius=r,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,cornerRadius:s.cornerRadius}}catch(o){throw console.error("Error setting corner radius:",o),new Error(`Failed to set corner radius: ${o.message||o}`)}}async function Be(e){const t=e.nodeId||e.Node_ID,n=e.topLeft!==void 0?Number(e.topLeft):e.Top_Left_Radius,r=e.topRight!==void 0?Number(e.topRight):e.Top_Right_Radius,o=e.bottomLeft!==void 0?Number(e.bottomLeft):e.Bottom_Left_Radius,s=e.bottomRight!==void 0?Number(e.bottomRight):e.Bottom_Right_Radius;if(!t)throw new Error("Node ID is required");try{const i=await v(t);if(!i)throw new Error(`Node not found with ID: ${t}`);if(!("topLeftRadius"in i))throw new Error(`Node ${t} does not support individual corner radius`);const c=i;return n!==void 0&&(c.topLeftRadius=Number(n)),r!==void 0&&(c.topRightRadius=Number(r)),o!==void 0&&(c.bottomLeftRadius=Number(o)),s!==void 0&&(c.bottomRightRadius=Number(s)),figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),{success:!0,nodeId:i.id,name:i.name,type:i.type,cornerRadius:{topLeft:c.topLeftRadius,topRight:c.topRightRadius,bottomLeft:c.bottomLeftRadius,bottomRight:c.bottomRightRadius}}}catch(i){throw console.error("Error setting individual corner radius:",i),new Error(`Failed to set individual corner radius: ${i.message||i}`)}}async function We(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,s=W("Frame",e.name),i=e.parentIdForNode||e.parentId||null,c=figma.createFrame();if(c.x=t,c.y=n,c.resize(r,o),c.name=s,e.backgroundColor||e.Background_Color){const l=e.backgroundColor||e.Background_Color;c.fills=[S(l)]}if(e.layoutMode||e.Layout_Mode){const l=e.layoutMode||e.Layout_Mode;if(l==="HORIZONTAL"||l==="VERTICAL"){c.layoutMode=l,c.primaryAxisSizingMode="AUTO",c.counterAxisSizingMode="AUTO";const a=e.padding!==void 0?e.padding:10;c.paddingLeft=a,c.paddingRight=a,c.paddingTop=a,c.paddingBottom=a;const h=e.spacing!==void 0?e.spacing:10;c.itemSpacing=h}}const d=await O(c,i);return figma.currentPage.selection=[c],F(c,d)}async function Ue(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.direction||e.Direction||"HORIZONTAL",o=e.spacing!==void 0?Number(e.spacing):10,s=e.padding!==void 0?Number(e.padding):20,i=W("Auto Layout",e.name),c=e.parentIdForNode||e.parentId||null,d=figma.createFrame();d.x=t,d.y=n,d.name=i,d.layoutMode=r,d.primaryAxisSizingMode="AUTO",d.counterAxisSizingMode="AUTO",d.itemSpacing=o,d.paddingLeft=s,d.paddingRight=s,d.paddingTop=s,d.paddingBottom=s;const l=e.primaryAxisAlign||"MIN",a=e.counterAxisAlign||"MIN";l==="CENTER"?d.primaryAxisAlignItems="CENTER":l==="MAX"?d.primaryAxisAlignItems="MAX":d.primaryAxisAlignItems="MIN",a==="CENTER"?d.counterAxisAlignItems="CENTER":a==="MAX"?d.counterAxisAlignItems="MAX":d.counterAxisAlignItems="MIN",e.backgroundColor&&(d.fills=[S(e.backgroundColor)]);const h=await O(d,c);return figma.currentPage.selection=[d],G(q({},F(d,h)),{layoutMode:d.layoutMode,itemSpacing:d.itemSpacing,padding:{left:d.paddingLeft,right:d.paddingRight,top:d.paddingTop,bottom:d.paddingBottom}})}async function qe(e){var d,l;const t=e.componentId||e.Component_ID,n=e.x!==void 0?Number(e.x):0,r=e.y!==void 0?Number(e.y):0,o=e.name||e.Name,s=e.parentIdForNode||e.parentId||null,i=e.componentProperties||e.properties||e.variants||{},c=e.overrides||{};if(!t)throw new Error("Component ID is required");try{const a=ee(t),h=await v(a);if(!h)throw new Error(`Component not found with ID: ${t} (normalized: ${a})`);if(h.type!=="COMPONENT"&&h.type!=="COMPONENT_SET")throw new Error(`Node ${t} is not a component (type: ${h.type})`);let f;if(h.type==="COMPONENT")f=h.createInstance();else{const w=h.defaultVariant;if(!w)throw new Error("Component set has no default variant");f=w.createInstance()}const g=await f.getMainComponentAsync();let u={};if(Object.keys(i).length>0)try{if(g){let w={};if(((d=g.parent)==null?void 0:d.type)==="COMPONENT_SET"){const E=g.parent;E.componentPropertyDefinitions&&(w=E.componentPropertyDefinitions)}else g.componentPropertyDefinitions&&(w=g.componentPropertyDefinitions);const p={};Object.keys(w).forEach(E=>{const N=E.split("#")[0];p[N]=E});const I={};Object.entries(i).forEach(([E,N])=>{const b=p[E]||E;I[b]=N}),Object.keys(I).length>0&&(f.setProperties(I),u=I,console.log("✅ Applied component properties with key mapping:",{userProvided:i,keyMapping:p,actualApplied:I}))}else f.setProperties(i),u=i}catch(w){console.warn("Error setting component properties:",w);try{f.setProperties(i),u=i,console.log("Applied properties without mapping as fallback")}catch(p){console.warn("Fallback property setting also failed:",p)}}f.x=n,f.y=r,o&&(f.name=o),Object.keys(c).length>0&&Ge(f,c);const m=await O(f,s);figma.currentPage.selection=[f],figma.viewport.scrollAndZoomIntoView([f]);const y={mainComponent:g?{id:g.id,name:g.name,key:g.key}:null,componentProperties:f.componentProperties||{},availableProperties:[],appliedProperties:u,originalPropertiesInput:i};if(g)try{let w={};if(((l=g.parent)==null?void 0:l.type)==="COMPONENT_SET"){const p=g.parent;p.componentPropertyDefinitions&&(w=p.componentPropertyDefinitions)}else g.componentPropertyDefinitions&&(w=g.componentPropertyDefinitions);Object.keys(w).length>0&&(y.availableProperties=Object.entries(w).map(([p,I])=>{var E;return{key:p,type:I.type,defaultValue:I.defaultValue,currentValue:(E=f.componentProperties)==null?void 0:E[p],variantOptions:I.type==="VARIANT"?I.variantOptions:void 0}}))}catch(w){console.warn("Error getting available properties:",w)}try{const w=f.exposedInstances||[];y.exposedInstances=w.map(p=>({name:p.name,type:p.type}))}catch(w){console.warn("Error getting exposed instances:",w)}return G(q({},F(f,m)),{mainComponentId:g==null?void 0:g.id,appliedProperties:u,originalPropertiesInput:i,hasOverrides:Object.keys(c).length>0,instanceDetails:y})}catch(a){throw console.error("Error creating instance:",a),new Error(`Failed to create instance: ${a.message||a}`)}}function Ge(e,t){if(t.text||t.characters){const n=t.text||t.characters;for(const[r,o]of Object.entries(n)){const s=e.findOne(i=>i.id===r&&i.type==="TEXT");s&&(s.characters=o)}}if(t.fills)for(const[n,r]of Object.entries(t.fills)){const o=e.findOne(s=>s.id===n);o&&"fills"in o&&(o.fills=r)}if(t.visible)for(const[n,r]of Object.entries(t.visible)){const o=e.findOne(s=>s.id===n);o&&(o.visible=r)}}async function Xe(e){const t=e.nodeId||e.Node_ID,n=e.gridType||e.Grid_Type||"GRID",r=e.count!==void 0?Number(e.count):12,o=e.offset!==void 0?Number(e.offset):0,s=e.gutter!==void 0?Number(e.gutter):20,i=e.color||{r:1,g:0,b:0,a:.1};if(!t)throw new Error("Node ID is required");try{const c=await v(t);if(!c)throw new Error(`Node not found with ID: ${t}`);if(!("layoutGrids"in c))throw new Error(`Node ${t} does not support layout grids`);const d=c;let l;switch(n.toUpperCase()){case"COLUMNS":l={pattern:"COLUMNS",alignment:"STRETCH",count:r,offset:o,gutterSize:s,color:i,visible:!0};break;case"ROWS":l={pattern:"ROWS",alignment:"STRETCH",count:r,offset:o,gutterSize:s,color:i,visible:!0};break;case"GRID":default:l={pattern:"GRID",sectionSize:e.sectionSize||10,color:i,visible:!0};break}return d.layoutGrids=[l],figma.currentPage.selection=[c],figma.viewport.scrollAndZoomIntoView([c]),{success:!0,nodeId:c.id,name:c.name,type:c.type,layoutGrid:l}}catch(c){throw console.error("Error setting layout grid:",c),new Error(`Failed to set layout grid: ${c.message||c}`)}}async function He(e){const t=e.nodeId||e.Node_ID,n=e.layoutMode||e.Layout_Mode||e.mode;if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Layout mode is required");try{const r=await v(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("layoutMode"in r))throw new Error(`Node ${t} does not support layout mode (type: ${r.type})`);const o=r;if(n==="NONE")o.layoutMode="NONE";else if(n==="HORIZONTAL"||n==="VERTICAL")o.layoutMode=n,o.primaryAxisSizingMode==="FIXED"&&(o.primaryAxisSizingMode="AUTO"),o.counterAxisSizingMode==="FIXED"&&(o.counterAxisSizingMode="AUTO");else throw new Error(`Invalid layout mode: ${n}. Must be NONE, HORIZONTAL, or VERTICAL`);return figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,layoutMode:o.layoutMode,primaryAxisSizingMode:o.primaryAxisSizingMode,counterAxisSizingMode:o.counterAxisSizingMode}}catch(r){throw console.error("Error setting layout mode:",r),new Error(`Failed to set layout mode: ${r.message||r}`)}}async function Ze(e){const t=e.nodeId||e.Node_ID,n=e.padding!==void 0?Number(e.padding):e.Padding,r=e.paddingLeft!==void 0?Number(e.paddingLeft):e.Padding_Left,o=e.paddingRight!==void 0?Number(e.paddingRight):e.Padding_Right,s=e.paddingTop!==void 0?Number(e.paddingTop):e.Padding_Top,i=e.paddingBottom!==void 0?Number(e.paddingBottom):e.Padding_Bottom;if(!t)throw new Error("Node ID is required");try{const c=await v(t);if(!c)throw new Error(`Node not found with ID: ${t}`);if(!("paddingLeft"in c))throw new Error(`Node ${t} does not support padding (type: ${c.type})`);const d=c;return n!==void 0?(d.paddingLeft=n,d.paddingRight=n,d.paddingTop=n,d.paddingBottom=n):(r!==void 0&&(d.paddingLeft=r),o!==void 0&&(d.paddingRight=o),s!==void 0&&(d.paddingTop=s),i!==void 0&&(d.paddingBottom=i)),figma.currentPage.selection=[c],figma.viewport.scrollAndZoomIntoView([c]),{success:!0,nodeId:c.id,name:c.name,type:c.type,padding:{left:d.paddingLeft,right:d.paddingRight,top:d.paddingTop,bottom:d.paddingBottom}}}catch(c){throw console.error("Error setting padding:",c),new Error(`Failed to set padding: ${c.message||c}`)}}async function je(e){const t=e.nodeId||e.Node_ID,n=e.spacing!==void 0?Number(e.spacing):e.Item_Spacing!==void 0?Number(e.Item_Spacing):e.itemSpacing;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("Spacing value is required");try{const r=await v(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("itemSpacing"in r))throw new Error(`Node ${t} does not support item spacing (type: ${r.type})`);const o=r;if(o.layoutMode==="NONE")throw new Error(`Node ${t} must have auto-layout enabled to set item spacing`);return o.itemSpacing=Number(n),figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,itemSpacing:o.itemSpacing,layoutMode:o.layoutMode}}catch(r){throw console.error("Error setting item spacing:",r),new Error(`Failed to set item spacing: ${r.message||r}`)}}async function Ye(e){if(figma.editorType!=="figma")throw new Error("Component creation is only available in Design mode");let t=e.nodeIds||[];if(typeof t=="string"&&(t=t.split(",").map(o=>o.trim()).filter(o=>o.length>0)),Array.isArray(t)||(t=[t]),!t||t.length===0)throw new Error("At least one node ID is required to create a component");const n=e.name||e.Name||"Component",r=e.description||e.Description||"";try{const o=[];for(const i of t){const c=ee(i),d=await v(c);if(!d)throw new Error(`Node not found with ID: ${i} (normalized: ${c})`);o.push(d)}for(const i of o)if(!("x"in i&&"y"in i))throw new Error(`Node ${i.id} (${i.type}) cannot be converted to component`);let s;if(o.length===1){const i=o[0];if(i.type==="FRAME"||i.type==="GROUP"||i.type==="COMPONENT"||i.type==="INSTANCE"){if(s=figma.createComponentFromNode(i),!s)throw new Error("Failed to create component from node")}else{const c=figma.createFrame(),d={x:i.x,y:i.y,width:"width"in i?i.width:100,height:"height"in i?i.height:100};c.x=d.x,c.y=d.y,c.resize(d.width,d.height),c.name=n;const l=i.parent;if(l&&"appendChild"in l&&l.appendChild(c),i.x=0,i.y=0,c.appendChild(i),s=figma.createComponentFromNode(c),!s)throw new Error("Failed to create component from frame")}}else{let i=1/0,c=1/0,d=-1/0,l=-1/0;for(const u of o)i=Math.min(i,u.x),c=Math.min(c,u.y),"width"in u&&"height"in u&&(d=Math.max(d,u.x+u.width),l=Math.max(l,u.y+u.height));const a=d-i,h=l-c,f=figma.createFrame();f.x=i,f.y=c,f.resize(a,h),f.name=n;const g=o[0].parent;g&&"appendChild"in g&&g.appendChild(f);for(const u of o){const m=u.x-i,y=u.y-c;f.appendChild(u),u.x=m,u.y=y}if(s=figma.createComponentFromNode(f),!s)throw new Error("Failed to create component from frame")}return s.name=n,r&&(s.description=r),figma.currentPage.selection=[s],figma.viewport.scrollAndZoomIntoView([s]),{success:!0,nodeId:s.id,name:s.name,type:s.type,componentId:s.id,key:s.key,childrenCount:"children"in s?s.children.length:0,x:s.x,y:s.y,width:s.width,height:s.height}}catch(o){throw console.error("Error creating component from nodes:",o),new Error(`Failed to create component from nodes: ${o.message||o}`)}}async function Je(e){const t=e.nodeId||e.Node_ID,n=e.primaryAlign||e.Primary_Align,r=e.counterAlign||e.Counter_Align;if(!t)throw new Error("Node ID is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("layoutMode"in o))throw new Error(`Node ${t} does not support layout alignment (type: ${o.type})`);const s=o;if(s.layoutMode==="NONE")throw new Error(`Node ${t} must have auto-layout enabled to set axis alignment`);if(n){const i=n.toUpperCase();if(["MIN","CENTER","MAX","SPACE_BETWEEN"].includes(i))s.primaryAxisAlignItems=i;else throw new Error(`Invalid primary align value: ${n}. Must be MIN, CENTER, MAX, or SPACE_BETWEEN`)}if(r){const i=r.toUpperCase();if(["MIN","CENTER","MAX"].includes(i))s.counterAxisAlignItems=i;else throw new Error(`Invalid counter align value: ${r}. Must be MIN, CENTER, or MAX`)}return figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,layoutMode:s.layoutMode,primaryAxisAlignItems:s.primaryAxisAlignItems,counterAxisAlignItems:s.counterAxisAlignItems}}catch(o){throw console.error("Error setting axis alignment:",o),new Error(`Failed to set axis alignment: ${o.message||o}`)}}async function Ke(e){const t=e.nodeId||e.Node_ID,n=e.primarySizing||e.Primary_Sizing,r=e.counterSizing||e.Counter_Sizing;if(!t)throw new Error("Node ID is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("layoutMode"in o))throw new Error(`Node ${t} does not support layout sizing (type: ${o.type})`);const s=o;if(s.layoutMode==="NONE")throw new Error(`Node ${t} must have auto-layout enabled to set layout sizing`);if(n){const i=n.toUpperCase();if(["FIXED","AUTO"].includes(i))s.primaryAxisSizingMode=i;else throw new Error(`Invalid primary sizing value: ${n}. Must be FIXED or AUTO`)}if(r){const i=r.toUpperCase();if(["FIXED","AUTO"].includes(i))s.counterAxisSizingMode=i;else throw new Error(`Invalid counter sizing value: ${r}. Must be FIXED or AUTO`)}return figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,layoutMode:s.layoutMode,primaryAxisSizingMode:s.primaryAxisSizingMode,counterAxisSizingMode:s.counterAxisSizingMode}}catch(o){throw console.error("Error setting layout sizing:",o),new Error(`Failed to set layout sizing: ${o.message||o}`)}}async function Qe(e){const t=e.nodeId||e.Node_ID,n=e.annotation||e.Annotation||e.text,r=e.type||e.Type||"NOTE";if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Annotation text is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);const s={type:r,text:n,timestamp:new Date().toISOString()};let i=!1;if("description"in o)try{const c=o.description||"",d=`[${r}] ${n}`;c?o.description=`${c}
${d}`:o.description=d,i=!0}catch(c){console.warn("Failed to set description:",c)}try{const c=o.getPluginData("figmation-annotations");let d=[];if(c)try{d=JSON.parse(c)}catch(l){console.warn("Failed to parse existing annotation data:",l)}d.push(s),o.setPluginData("figmation-annotations",JSON.stringify(d))}catch(c){console.warn("Failed to store annotation as plugin data:",c)}return figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,annotation:s,storedAsDescription:i,storedAsPluginData:!0,description:"description"in o?o.description:void 0}}catch(o){throw console.error("Error setting annotation:",o),new Error(`Failed to set annotation: ${o.message||o}`)}}async function et(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r={success:!0,nodeId:n.id,name:n.name,type:n.type,annotations:[],description:null};try{const o=n.getPluginData("figmation-annotations");o&&(r.annotations=JSON.parse(o))}catch(o){console.warn("Failed to get plugin data annotations:",o)}return"description"in n&&(r.description=n.description||null),r}catch(n){throw console.error("Error getting annotations:",n),new Error(`Failed to get annotations: ${n.message||n}`)}}async function tt(e){const t=e.nodeId||e.Node_ID,n=e.x!==void 0?Number(e.x):e.X,r=e.y!==void 0?Number(e.y):e.Y,o=e.deltaX!==void 0?Number(e.deltaX):e.Delta_X,s=e.deltaY!==void 0?Number(e.deltaY):e.Delta_Y;if(!t)throw new Error("Node ID is required");try{const i=await v(t);if(!i)throw new Error(`Node not found with ID: ${t}`);if(!("x"in i&&"y"in i))throw new Error(`Node ${t} cannot be moved (not a scene node)`);const c=i;return n!==void 0?c.x=Number(n):o!==void 0&&(c.x+=Number(o)),r!==void 0?c.y=Number(r):s!==void 0&&(c.y+=Number(s)),figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),{success:!0,nodeId:i.id,name:i.name,type:i.type,x:c.x,y:c.y}}catch(i){throw console.error("Error moving node:",i),new Error(`Failed to move node: ${i.message||i}`)}}async function ot(e){const t=e.nodeId||e.Node_ID,n=e.width!==void 0?Number(e.width):e.Width,r=e.height!==void 0?Number(e.height):e.Height;if(!t)throw new Error("Node ID is required");if(n===void 0&&r===void 0)throw new Error("At least one dimension (width or height) is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("width"in o&&"height"in o&&"resize"in o))throw new Error(`Node ${t} cannot be resized`);const s=o,i=n!==void 0?Number(n):s.width,c=r!==void 0?Number(r):s.height;return s.resize(i,c),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,width:s.width,height:s.height}}catch(o){throw console.error("Error resizing node:",o),new Error(`Failed to resize node: ${o.message||o}`)}}async function de(e){const t=e.nodeId||e.Node_ID,n=e.angle!==void 0?Number(e.angle):e.Angle,r=e.delta!==void 0?Number(e.delta):e.Delta;if(!t)throw new Error("Node ID is required");if(n===void 0&&r===void 0)throw new Error("Either angle or delta is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("rotation"in o))throw new Error(`Node ${t} cannot be rotated`);const s=o;return n!==void 0?s.rotation=Number(n):r!==void 0&&(s.rotation=(s.rotation||0)+Number(r)),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,rotation:s.rotation}}catch(o){throw console.error("Error rotating node:",o),new Error(`Failed to rotate node: ${o.message||o}`)}}async function nt(e){const t=G(q({},e),{angle:e.rotation!==void 0?e.rotation:e.Rotation!==void 0?e.Rotation:e.angle});return await de(t)}async function rt(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r={id:n.id,name:n.name,type:n.type};return n.remove(),{success:!0,nodeId:r.id,name:r.name,type:r.type,deleted:!0}}catch(n){throw console.error("Error deleting node:",n),new Error(`Failed to delete node: ${n.message||n}`)}}async function it(e){const t=e.nodeId||e.Node_ID,n=e.offsetX!==void 0?Number(e.offsetX):20,r=e.offsetY!==void 0?Number(e.offsetY):20;if(!t)throw new Error("Node ID is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("clone"in o))throw new Error(`Node ${t} cannot be cloned`);const i=o.clone();return"x"in i&&"y"in i&&(i.x=i.x+n,i.y=i.y+r),i.name=`${o.name} (Copy)`,figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),{success:!0,nodeId:i.id,name:i.name,type:i.type,x:"x"in i?i.x:0,y:"y"in i?i.y:0,originalNodeId:o.id}}catch(o){throw console.error("Error cloning node:",o),new Error(`Failed to clone node: ${o.message||o}`)}}async function oe(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];const n=e.name||e.Name||e.groupName||e.Group_Name||"Group",r=e.parentId||e.Parent_Node_ID||e.parent_node_id||null;if(typeof t=="string"&&(t=t.split(",").map(o=>o.trim()).filter(o=>o.length>0)),console.log("groupNodes received params:",JSON.stringify(e,null,2)),console.log("Parsed nodeIds:",t),console.log("Group name:",n),!Array.isArray(t)||t.length===0)throw new Error("Node IDs array is required");try{const o=[];for(const c of t){const d=await v(c);if(!d)throw new Error(`Node not found with ID: ${c}`);if(!H(d))throw new Error(`Node '${c}' cannot be grouped (not a valid scene node type)`);o.push(d)}const s=figma.group(o,figma.currentPage);s.name=n;let i=figma.currentPage.id;if(r)try{const c=await v(r);c&&"appendChild"in c?(c.appendChild(s),i=c.id,console.log(`Group moved to parent: ${c.name} (${r})`)):console.warn(`Parent node ${r} cannot contain children, keeping in current page`)}catch(c){console.warn(`Failed to move group to parent ${r}:`,c)}return figma.currentPage.selection=[s],figma.viewport.scrollAndZoomIntoView([s]),{success:!0,nodeId:s.id,name:s.name,type:s.type,parentId:i,childrenCount:s.children.length,groupedNodeIds:t}}catch(o){throw console.error("Error grouping nodes:",o),new Error(`Failed to group nodes: ${o.message||o}`)}}async function st(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);if(n.type!=="GROUP")throw new Error(`Node ${t} is not a group (type: ${n.type})`);const r=n,o=r.children.map(i=>i.id),s=r.parent;return figma.ungroup(r),{success:!0,nodeId:t,ungrouped:!0,childrenIds:o,parentId:(s==null?void 0:s.id)||null}}catch(n){throw console.error("Error ungrouping node:",n),new Error(`Failed to ungroup node: ${n.message||n}`)}}async function ct(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];const n=e.scrollIntoView!==void 0?e.scrollIntoView:!0;if(typeof t=="string"&&(t=t.split(",").map(r=>r.trim()).filter(r=>r.length>0)),Array.isArray(t)||(t=[t]),!t||t.length===0)throw new Error("At least one node ID is required");try{const r=[],o=[];for(const s of t)try{const i=await v(s);if(!i){o.push({id:s,error:"Node not found"});continue}if(!H(i)){o.push({id:s,error:"Node cannot be selected (not a scene node)"});continue}let c=i.parent,d=!1;for(;c;){if(c.id===figma.currentPage.id){d=!0;break}c=c.parent}if(!d){o.push({id:s,error:"Node is not on the current page"});continue}r.push(i)}catch(i){o.push({id:s,error:i.message||"Unknown error"})}return figma.currentPage.selection=r,n&&r.length>0&&figma.viewport.scrollAndZoomIntoView(r),{success:!0,selectedNodes:r.map(s=>({id:s.id,name:s.name,type:s.type})),selectedCount:r.length,errors:o.length>0?o:void 0,totalRequested:t.length}}catch(r){throw console.error("Error selecting nodes:",r),new Error(`Failed to select nodes: ${r.message||r}`)}}async function dt(e){const t=e.nodeType||e.Node_Type||e.type,n=e.parentId||e.Parent_ID,r=e.scrollIntoView!==void 0?e.scrollIntoView:!0;if(!t)throw new Error("Node type is required");try{let o=function(c){if(c.type===t.toUpperCase()&&H(c)&&i.push(c),"children"in c)for(const d of c.children)o(d)},s;if(n){const c=await v(n);if(!c)throw new Error(`Parent node not found with ID: ${n}`);s=c}else s=figma.currentPage;const i=[];return o(s),figma.currentPage.selection=i,r&&i.length>0&&figma.viewport.scrollAndZoomIntoView(i),{success:!0,selectedNodes:i.map(c=>({id:c.id,name:c.name,type:c.type})),selectedCount:i.length,nodeType:t.toUpperCase(),searchScope:n||"current page"}}catch(o){throw console.error("Error selecting nodes by type:",o),new Error(`Failed to select nodes by type: ${o.message||o}`)}}async function lt(e){const t=e.namePattern||e.Name_Pattern||e.pattern||e.name,n=e.exactMatch!==void 0?e.exactMatch:!1,r=e.caseSensitive!==void 0?e.caseSensitive:!1,o=e.parentId||e.Parent_ID,s=e.scrollIntoView!==void 0?e.scrollIntoView:!0;if(!t)throw new Error("Name pattern is required");try{let i=function(a){const h=r?a.name:a.name.toLowerCase();if((n?h===l:h.includes(l))&&H(a)&&d.push(a),"children"in a)for(const g of a.children)i(g)},c;if(o){const a=await v(o);if(!a)throw new Error(`Parent node not found with ID: ${o}`);c=a}else c=figma.currentPage;const d=[],l=r?t:t.toLowerCase();return i(c),figma.currentPage.selection=d,s&&d.length>0&&figma.viewport.scrollAndZoomIntoView(d),{success:!0,selectedNodes:d.map(a=>({id:a.id,name:a.name,type:a.type})),selectedCount:d.length,namePattern:t,exactMatch:n,caseSensitive:r,searchScope:o||"current page"}}catch(i){throw console.error("Error selecting nodes by name:",i),new Error(`Failed to select nodes by name: ${i.message||i}`)}}async function at(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(!t||!t.length)throw new Error("Node IDs are required");typeof t=="string"&&(t=t.split(",").map(n=>n.trim()).filter(n=>n.length>0)),Array.isArray(t)||(t=[t]);try{const n=[],r=[];for(const o of t)try{const s=await v(o);if(!s){r.push({id:o,error:"Node not found"});continue}n.push({id:s.id,name:s.name,type:s.type}),s.remove()}catch(s){r.push({id:o,error:s.message||"Unknown error"})}return figma.currentPage.selection=[],{success:!0,deletedNodes:n,deletedCount:n.length,errors:r.length>0?r:void 0,totalRequested:t.length}}catch(n){throw console.error("Error deleting multiple nodes:",n),new Error(`Failed to delete multiple nodes: ${n.message||n}`)}}async function ft(e){var n,r,o;const t=e.sourceInstanceId||e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const s=await v(t);if(!s)throw new Error(`Node not found with ID: ${t}`);if(s.type!=="INSTANCE")throw new Error(`Node ${t} is not an instance (type: ${s.type})`);const i=s,c={characters:{},fills:{},visible:{},layoutAlign:{},layoutGrow:{},constraints:{},effects:{},componentProperties:{}};async function d(g,u,m=""){if("children"in g&&"children"in u){const y=g.children,w=u.children;for(let p=0;p<y.length&&p<w.length;p++){const I=y[p],E=w[p],N=m?`${m}.${I.id}`:I.id;if(I.type==="TEXT"&&E.type==="TEXT"){const b=I,_=E;b.characters!==_.characters&&(c.characters[N]={original:_.characters,override:b.characters})}if("fills"in I&&"fills"in E){const b=JSON.stringify(I.fills),_=JSON.stringify(E.fills);b!==_&&(c.fills[N]={original:E.fills,override:I.fills})}if(I.visible!==E.visible&&(c.visible[N]={original:E.visible,override:I.visible}),"effects"in I&&"effects"in E){const b=JSON.stringify(I.effects),_=JSON.stringify(E.effects);b!==_&&(c.effects[N]={original:E.effects,override:I.effects})}if(I.type==="INSTANCE"&&E.type==="INSTANCE"){const b=I,_=E,C=await b.getMainComponentAsync(),P=await _.getMainComponentAsync();C&&P&&await d(b,C,N)}else"children"in I&&"children"in E&&await d(I,E,N)}}}i.componentProperties&&(c.componentProperties=i.componentProperties);const l=await i.getMainComponentAsync();l&&await d(i,l);const a={};for(const[g,u]of Object.entries(c))Object.keys(u).length>0&&(a[g]=u);let h={};if(l)try{if(((n=l.parent)==null?void 0:n.type)==="COMPONENT_SET"){const g=l.parent;if(g.componentPropertyDefinitions)for(const[u,m]of Object.entries(g.componentPropertyDefinitions))h[u]={type:m.type,defaultValue:m.defaultValue,variantOptions:m.variantOptions,currentValue:((r=i.componentProperties)==null?void 0:r[u])||m.defaultValue,description:m.type==="TEXT"?"Text property - can be modified via [Set Instance Overrides]":void 0}}else if(l.componentPropertyDefinitions&&l.componentPropertyDefinitions)for(const[g,u]of Object.entries(l.componentPropertyDefinitions))h[g]={type:u.type,defaultValue:u.defaultValue,variantOptions:u.variantOptions,currentValue:((o=i.componentProperties)==null?void 0:o[g])||u.defaultValue,description:u.type==="TEXT"?"Text property - can be modified via [Set Instance Overrides]":void 0}}catch(g){console.warn("Error getting available properties:",g)}const f={id:i.id,name:i.name,type:i.type,x:i.x,y:i.y,width:i.width,height:i.height,visible:i.visible,locked:i.locked,opacity:i.opacity,blendMode:i.blendMode,mainComponent:l?{id:l.id,name:l.name,key:l.key}:null,componentProperties:i.componentProperties||{},availableProperties:[],exposedInstances:[]};f.availableProperties=Object.entries(h).map(([g,u])=>({key:g,type:u.type,defaultValue:u.defaultValue,currentValue:u.currentValue,variantOptions:u.variantOptions,description:u.description}));try{const g=i.exposedInstances||[];f.exposedInstances=g.map(u=>({name:u.name,type:u.type}))}catch(g){console.warn("Error getting exposed instances:",g)}return"layoutMode"in i&&(f.layoutMode=i.layoutMode,i.layoutMode!=="NONE"&&(f.layoutDirection="layoutDirection"in i?i.layoutDirection:null,f.itemSpacing=i.itemSpacing,f.paddingLeft=i.paddingLeft,f.paddingRight=i.paddingRight,f.paddingTop=i.paddingTop,f.paddingBottom=i.paddingBottom)),"fills"in i&&i.fills!==figma.mixed&&(f.fillsCount=Array.isArray(i.fills)?i.fills.length:0),"strokes"in i&&(f.strokesCount=Array.isArray(i.strokes)?i.strokes.length:0,f.strokeWeight=i.strokeWeight),"effects"in i&&(f.effectsCount=Array.isArray(i.effects)?i.effects.length:0,i.effects.length>0&&(f.effectTypes=i.effects.map(g=>g.type))),"constraints"in i&&(f.constraints=i.constraints),{success:!0,nodeId:i.id,nodeName:i.name,nodeType:i.type,mainComponentId:l==null?void 0:l.id,mainComponentName:l==null?void 0:l.name,overrides:a,hasOverrides:Object.keys(a).length>0,availableProperties:h,componentProperties:i.componentProperties||{},instanceDetails:f}}catch(s){throw console.error("Error getting instance overrides:",s),new Error(`Failed to get instance overrides: ${s.message||s}`)}}async function ut(e){var r,o;const t=e.nodeId||e.Node_ID,n=e.overrides||e.Overrides||{};if(!t)throw new Error("Node ID is required");try{const s=await v(t);if(!s)throw new Error(`Node not found with ID: ${t}`);if(s.type!=="INSTANCE")throw new Error(`Node ${t} is not an instance (type: ${s.type})`);const i=s;let c=0,d=0,l=0;const a={},h={};if(n.componentProperties){console.log("Setting component properties:",n.componentProperties);const m=await i.getMainComponentAsync();let y={};if(m)try{if(((r=m.parent)==null?void 0:r.type)==="COMPONENT_SET"){const I=m.parent;I.componentPropertyDefinitions&&(y=I.componentPropertyDefinitions,console.log("Available properties from Component Set:",Object.keys(y)))}else m.componentPropertyDefinitions&&(y=m.componentPropertyDefinitions,console.log("Available properties from Component:",Object.keys(y)))}catch(I){console.warn("Error getting available properties for validation:",I)}const w={};Object.keys(y).forEach(I=>{const E=I.split("#")[0];w[E]=I}),console.log("Key mapping for dynamic IDs:",w);const p={};for(const[I,E]of Object.entries(n.componentProperties)){l++;let N=w[I]||I;console.log(`Attempting to set property "${I}" (mapped to "${N}") to "${E}"`);let b=y[N];if(Object.keys(y).length>0&&!b){console.warn(`Property "${N}" is not available in component. Available properties:`,Object.keys(y));const _=y[I];if(!_)continue;b=_,N=I}if(b)if(b.type==="TEXT")console.log(`Property "${N}" is a TEXT property`),p[N]=String(E),h[I]=String(E),d++;else if(b.type==="VARIANT"){if(b.variantOptions&&!b.variantOptions.includes(E)){console.warn(`Value "${E}" is not valid for property "${N}". Valid options:`,b.variantOptions);continue}p[N]=E,a[I]=E,c++}else if(b.type==="BOOLEAN"){const _=E===!0||E==="true"||E===1||E==="1";p[N]=_,a[I]=_,c++}else b.type==="INSTANCE_SWAP"&&(p[N]=E,a[I]=E,c++);else p[N]=E,a[I]=E,c++}if(Object.keys(p).length>0)try{i.setProperties(p),console.log("✅ Successfully applied properties with key mapping:",{userProvided:n.componentProperties,keyMapping:w,actualApplied:p})}catch(I){console.error("Failed to set properties:",I),console.error("Properties that failed:",p);try{i.setProperties(n.componentProperties),console.log("Applied properties without mapping as fallback"),Object.entries(n.componentProperties).forEach(([E,N])=>{a[E]=N,c++})}catch(E){throw console.error("Fallback property setting also failed:",E),I}}}figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]);const f=c+d,g=await i.getMainComponentAsync(),u={id:i.id,name:i.name,type:i.type,x:i.x,y:i.y,width:i.width,height:i.height,visible:i.visible,locked:i.locked,opacity:i.opacity,blendMode:i.blendMode,mainComponent:g?{id:g.id,name:g.name,key:g.key}:null,componentProperties:i.componentProperties||{},availableProperties:[],exposedInstances:[]};if(g)try{let m={};if(((o=g.parent)==null?void 0:o.type)==="COMPONENT_SET"){const y=g.parent;y.componentPropertyDefinitions&&(m=y.componentPropertyDefinitions)}else g.componentPropertyDefinitions&&(m=g.componentPropertyDefinitions);Object.keys(m).length>0&&(u.availableProperties=Object.entries(m).map(([y,w])=>{var p;return{key:y,type:w.type,defaultValue:w.defaultValue,currentValue:(p=i.componentProperties)==null?void 0:p[y],variantOptions:w.type==="VARIANT"?w.variantOptions:void 0}}))}catch(m){console.warn("Error getting available properties:",m)}try{const m=i.exposedInstances||[];u.exposedInstances=m.map(y=>({name:y.name,type:y.type}))}catch(m){console.warn("Error getting exposed instances:",m)}return"layoutMode"in i&&(u.layoutMode=i.layoutMode,i.layoutMode!=="NONE"&&(u.layoutDirection="layoutDirection"in i?i.layoutDirection:null,u.itemSpacing=i.itemSpacing,u.paddingLeft=i.paddingLeft,u.paddingRight=i.paddingRight,u.paddingTop=i.paddingTop,u.paddingBottom=i.paddingBottom)),"fills"in i&&i.fills!==figma.mixed&&(u.fillsCount=Array.isArray(i.fills)?i.fills.length:0),"strokes"in i&&(u.strokesCount=Array.isArray(i.strokes)?i.strokes.length:0,u.strokeWeight=i.strokeWeight),"effects"in i&&(u.effectsCount=Array.isArray(i.effects)?i.effects.length:0,i.effects.length>0&&(u.effectTypes=i.effects.map(m=>m.type))),"constraints"in i&&(u.constraints=i.constraints),{success:!0,nodeId:i.id,nodeName:i.name,nodeType:i.type,componentPropertiesApplied:c,textPropertiesApplied:d,totalApplied:f,totalRequested:l,appliedProperties:a,appliedTextProperties:h,originalPropertiesInput:n.componentProperties,message:f>0?`Successfully applied ${f} properties (${c} component properties, ${d} text properties).`:"No properties were applied.",instanceDetails:u}}catch(s){console.error("Error setting instance overrides:",s);const i=s instanceof Error?s.message:String(s);throw new Error(`Failed to set instance overrides: ${i}`)}}async function gt(e){var n;const t=e.nodeId||e.Node_ID||e.instanceId;if(!t)throw new Error("Node ID is required");try{const r=await v(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(r.type!=="INSTANCE")throw new Error(`Node ${t} is not an instance (type: ${r.type})`);const o=r,s=await o.getMainComponentAsync(),i=s?{id:s.id,name:s.name,key:s.key}:null,c={id:o.id,name:o.name,x:o.x,y:o.y,width:o.width,height:o.height,visible:o.visible,locked:o.locked,opacity:o.opacity,blendMode:o.blendMode,componentProperties:o.componentProperties||{},availableProperties:[],exposedInstances:[]};if(s)try{let a={};if(((n=s.parent)==null?void 0:n.type)==="COMPONENT_SET"){const h=s.parent;h.componentPropertyDefinitions&&(a=h.componentPropertyDefinitions)}else s.componentPropertyDefinitions&&(a=s.componentPropertyDefinitions);Object.keys(a).length>0&&(c.availableProperties=Object.entries(a).map(([h,f])=>{var g;return{key:h,type:f.type,defaultValue:f.defaultValue,currentValue:(g=o.componentProperties)==null?void 0:g[h],variantOptions:f.type==="VARIANT"?f.variantOptions:void 0}}))}catch(a){console.warn("Error getting available properties before detach:",a)}try{const a=o.exposedInstances||[];c.exposedInstances=a.map(h=>({name:h.name,type:h.type}))}catch(a){console.warn("Error getting exposed instances before detach:",a)}const d=o.detachInstance();if(!d)throw new Error("Failed to detach instance - detachInstance returned null");const l={id:d.id,name:d.name,type:d.type,x:"x"in d?d.x:0,y:"y"in d?d.y:0,width:"width"in d?d.width:0,height:"height"in d?d.height:0,visible:d.visible,locked:d.locked,opacity:"opacity"in d?d.opacity:1,blendMode:"blendMode"in d?d.blendMode:"NORMAL"};return"layoutMode"in d&&(l.layoutMode=d.layoutMode,d.layoutMode!=="NONE"&&(l.layoutDirection="layoutDirection"in d?d.layoutDirection:null,l.itemSpacing=d.itemSpacing,l.paddingLeft=d.paddingLeft,l.paddingRight=d.paddingRight,l.paddingTop=d.paddingTop,l.paddingBottom=d.paddingBottom)),"fills"in d&&d.fills!==figma.mixed&&(l.fillsCount=Array.isArray(d.fills)?d.fills.length:0),"strokes"in d&&(l.strokesCount=Array.isArray(d.strokes)?d.strokes.length:0,l.strokeWeight=d.strokeWeight),"effects"in d&&(l.effectsCount=Array.isArray(d.effects)?d.effects.length:0,d.effects.length>0&&(l.effectTypes=d.effects.map(a=>a.type))),"constraints"in d&&(l.constraints=d.constraints),"children"in d&&(l.childrenCount=d.children.length),figma.currentPage.selection=[d],figma.viewport.scrollAndZoomIntoView([d]),{success:!0,nodeId:d.id,name:d.name,type:d.type,x:"x"in d?d.x:0,y:"y"in d?d.y:0,width:"width"in d?d.width:0,height:"height"in d?d.height:0,wasInstance:!0,originalInstanceId:c.id,mainComponent:i,detachedFrom:(i==null?void 0:i.name)||"Unknown Component",message:`Successfully detached instance from component: ${(i==null?void 0:i.name)||"Unknown"}`,instanceBeforeDetach:c,detachedNodeDetails:l}}catch(r){console.error("Error detaching instance:",r);const o=r instanceof Error?r.message:String(r);throw new Error(`Failed to detach instance: ${o}`)}}async function ht(e){const t=(e==null?void 0:e.svgContent)||(e==null?void 0:e.SVG_Content)||(e==null?void 0:e.svg_content),n=(e==null?void 0:e.x)||(e==null?void 0:e.X)||0,r=(e==null?void 0:e.y)||(e==null?void 0:e.Y)||0,o=(e==null?void 0:e.name)||(e==null?void 0:e.Name)||"Design",s=(e==null?void 0:e.parentId)||(e==null?void 0:e.Parent_Node_ID)||(e==null?void 0:e.parentIdForNode);if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");if(!t)throw new Error("SVG content is required");function i(l){let a=100,h=100;try{const f=l.match(/viewBox="([^"]+)"/i);if(f){const m=f[1].split(/\s+/);if(m.length>=4)return a=parseFloat(m[2]),h=parseFloat(m[3]),console.log(`Extracted dimensions from viewBox: ${a}x${h}`),{width:a,height:h}}const g=l.match(/<svg[^>]+width="([^"]+)"/i),u=l.match(/<svg[^>]+height="([^"]+)"/i);if(g&&u){const m=g[1],y=u[1],w=parseFloat(m.replace(/[^\d.]/g,"")),p=parseFloat(y.replace(/[^\d.]/g,""));if(!isNaN(w)&&!isNaN(p))return a=w,h=p,console.log(`Extracted dimensions from width/height attributes: ${a}x${h}`),{width:a,height:h}}console.log(`No valid dimensions found in SVG, using default: ${a}x${h}`)}catch(f){console.warn("Error extracting SVG dimensions:",f)}return{width:a,height:h}}const{width:c,height:d}=i(t);console.log("createDesignFromSvg params received:",JSON.stringify(e,null,2)),console.log("Extracted values:",{svgContent:t?`${t.substring(0,100)}...`:null,x:n,y:r,width:c,height:d,name:o,parentId:s});try{console.log("Creating design from SVG with params:",{svgContent:t==null?void 0:t.substring(0,100),width:c,height:d}),console.log("Using figma.createNodeFromSvg with SVG content");try{const f=figma.createNodeFromSvg(t);if(f){if(f.x=n,f.y=r,f.name=o,c&&d&&f.width&&f.height){const u=c/f.width,m=d/f.height,y=Math.min(u,m);f.resize(f.width*y,f.height*y)}const g=await O(f,s);return figma.currentPage.selection=[f],figma.viewport.scrollAndZoomIntoView([f]),console.log("Successfully created SVG using figma.createNodeFromSvg"),G(q({},F(f,g)),{success:!0})}}catch(f){console.log("figma.createNodeFromSvg failed, falling back to manual parsing:",f.message)}const l=figma.createFrame();l.name=o,l.x=n,l.y=r,l.resize(c,d),l.fills=[],l.clipsContent=!1,console.log("Parsing SVG content for geometric elements");async function a(f,g,u=null){const m=f.match(/<circle[^>]+>/g);m&&(console.log("Found circles:",m.length),m.forEach((N,b)=>{const _=N.match(/cx="([^"]+)"/),C=N.match(/cy="([^"]+)"/),P=N.match(/r="([^"]+)"/),M=N.match(/fill="([^"]+)"/);if(_&&C&&P){const $=parseFloat(_[1]),T=parseFloat(C[1]),x=parseFloat(P[1]),D=M?M[1]:"#000000",A=figma.createEllipse();if(A.name=`Circle ${b+1}`,A.resize(x*2,x*2),A.x=$-x,A.y=T-x,D!=="none"){const z=ie(D);A.fills=[{type:"SOLID",color:z}]}g.appendChild(A),console.log(`Created circle at (${$}, ${T}) with radius ${x}`)}}));const y=f.match(/<rect[^>]+>/g);y&&(console.log("Found rectangles:",y.length),y.forEach((N,b)=>{const _=N.match(/x="([^"]+)"/),C=N.match(/y="([^"]+)"/),P=N.match(/width="([^"]+)"/),M=N.match(/height="([^"]+)"/),$=N.match(/fill="([^"]+)"/),T=N.match(/rx="([^"]+)"/),x=N.match(/stroke="([^"]+)"/),D=N.match(/stroke-width="([^"]+)"/);if(P&&M){const A=_?parseFloat(_[1]):0,z=C?parseFloat(C[1]):0,V=parseFloat(P[1]),X=parseFloat(M[1]),K=$?$[1]:"#000000",j=T?parseFloat(T[1]):0,R=figma.createRectangle();if(R.name=`Rectangle ${b+1}`,R.x=A,R.y=z,R.resize(V,X),j>0&&(R.cornerRadius=j),K!=="none"&&!K.includes("url(")){const Y=B(K);R.fills=[{type:"SOLID",color:Y}]}else R.fills=[];if(x&&x[1]!=="none"){const Y=B(x[1]),k=D?parseFloat(D[1]):1;R.strokes=[{type:"SOLID",color:Y}],R.strokeWeight=k}g.appendChild(R),console.log(`Created rectangle at (${A}, ${z}) with size ${V}x${X}`)}}));const w=f.match(/<ellipse[^>]+>/g);w&&(console.log("Found ellipses:",w.length),w.forEach((N,b)=>{const _=N.match(/cx="([^"]+)"/),C=N.match(/cy="([^"]+)"/),P=N.match(/rx="([^"]+)"/),M=N.match(/ry="([^"]+)"/),$=N.match(/fill="([^"]+)"/);if(_&&C&&P&&M){const T=parseFloat(_[1]),x=parseFloat(C[1]),D=parseFloat(P[1]),A=parseFloat(M[1]),z=$?$[1]:"#000000",V=figma.createEllipse();if(V.name=`Ellipse ${b+1}`,V.resize(D*2,A*2),V.x=T-D,V.y=x-A,z!=="none"&&!z.includes("url(")){const X=B(z);V.fills=[{type:"SOLID",color:X}]}g.appendChild(V),console.log(`Created ellipse at (${T}, ${x}) with radii ${D}x${A}`)}}));const p=f.match(/<text[^>]*>([^<]*)<\/text>/g);if(p){console.log("Found text elements:",p.length);for(let N=0;N<p.length;N++){const b=p[N],_=b.match(/x="([^"]+)"/),C=b.match(/y="([^"]+)"/),P=b.match(/font-size="([^"]+)"/),M=b.match(/font-family="([^"]+)"/),$=b.match(/font-weight="([^"]+)"/),T=b.match(/fill="([^"]+)"/),x=b.match(/text-anchor="([^"]+)"/),D=b.match(/>([^<]+)</);if(_&&C&&D){const A=parseFloat(_[1]),z=parseFloat(C[1]),V=D[1].trim(),X=P?parseFloat(P[1]):16,K=M?M[1].split(",")[0].replace(/['"]/g,""):"Inter",j=$?parseInt($[1]):400,R=T?T[1]:"#000000",Y=x?x[1]:"start";try{const k=figma.createText();k.name=`Text ${N+1}`;let J="Regular";if(j>=700?J="Bold":j>=600?J="Semi Bold":j>=500&&(J="Medium"),await figma.loadFontAsync({family:"Inter",style:J}),k.fontName={family:"Inter",style:J},k.fontSize=X,k.characters=V,R!=="none"&&!R.includes("url(")){const ye=B(R);k.fills=[{type:"SOLID",color:ye}]}Y==="middle"?k.x=A-k.width/2:Y==="end"?k.x=A-k.width:k.x=A,k.y=z-X,g.appendChild(k),console.log(`Created text "${V}" at (${A}, ${z}) with size ${X}`)}catch(k){console.warn(`Failed to create text ${N+1}:`,k.message)}}}}const I=f.match(/<path[^>]+d="([^"]+)"[^>]*>/g);I&&(console.log("Found paths:",I.length),I.forEach((N,b)=>{const _=N.match(/d="([^"]+)"/),C=N.match(/fill="([^"]+)"/),P=N.match(/stroke="([^"]+)"/),M=N.match(/stroke-width="([^"]+)"/);if(_){const $=_[1],T=C?C[1]:"#000000";try{const x=figma.createVector();if(x.name=`Path ${b+1}`,x.vectorPaths=[{windingRule:"NONZERO",data:$}],T!=="none"&&!T.includes("url(")){const D=B(T);x.fills=[{type:"SOLID",color:D}]}if(P&&P[1]!=="none"){const D=B(P[1]),A=M?parseFloat(M[1]):1;x.strokes=[{type:"SOLID",color:D}],x.strokeWeight=A}g.appendChild(x),console.log(`Created path vector: ${$.substring(0,50)}...`)}catch(x){console.warn(`Failed to create path ${b+1}:`,x.message)}}}));const E=f.match(/<g[^>]*>([\s\S]*?)<\/g>/g);if(E){console.log("Found groups:",E.length);for(const N of E){const b=N.match(/<g[^>]*>([\s\S]*?)<\/g>/);if(b){const _=b[1],C=figma.createFrame();C.name="Group",C.fills=[],C.clipsContent=!1,g.appendChild(C),await a(_,C)}}}}if(await a(t,l),l.children.length>0)console.log(`Successfully created ${l.children.length} SVG elements`);else throw new Error("Could not extract any valid elements from SVG content. No circles or paths found.");const h=await O(l,s);return figma.currentPage.selection=[l],figma.viewport.scrollAndZoomIntoView([l]),G(q({},F(l,h)),{svgContent:t||null,components:{container:l.id,elementsCreated:l.children.length}})}catch(l){throw console.error("Error creating design from SVG:",l),new Error(`Failed to create design from SVG: ${l.message||l}`)}}function le(e){const t=e.replace(/^data:image\/[^;]+;base64,/,""),n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r={};for(let a=0;a<n.length;a++)r[n[a]]=a;const o=t.replace(/[^A-Za-z0-9+/=]/g,""),s=o.length;let i=Math.floor(s*.75),c=0;o.endsWith("==")?c=2:o.endsWith("=")&&(c=1),i-=c;const d=new Uint8Array(i);let l=0;for(let a=0;a<s;a+=4){const h=o[a]||"A",f=o[a+1]||"A",g=o[a+2]||"=",u=o[a+3]||"=",m=r[h]||0,y=r[f]||0,w=g==="="?0:r[g]||0,p=u==="="?0:r[u]||0;l<i&&(d[l++]=m<<2|y>>4),l<i&&g!=="="&&(d[l++]=(y&15)<<4|w>>2),l<i&&u!=="="&&(d[l++]=(w&3)<<6|p&63)}return d}async function yt(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.base64Data||e.Base64_Data||e.base64_data,n=e.mimeType||e.Mime_Type||e.mime_type||"image/png",r=e.x||e.X||e.X_Position||e.x_position||0,o=e.y||e.Y||e.Y_Position||e.y_position||0,s=e.width||e.Width||e.WIDTH||100,i=e.height||e.Height||e.HEIGHT||100,c=W("Image",e.name||e.Name||e.NAME),d=e.parentIdForNode||e.parentId||e.Parent_Node_ID||e.parent_node_id||null,l=e.cornerRadius||e.Corner_Radius||e.Image_Corner_Radius||e.image_corner_radius||0,a=e.scaleMode||e.Scale_Mode||e.scale_mode||"FILL";if(console.log("createImageFromUrl params received:",JSON.stringify(e,null,2)),console.log("Extracted values:",{base64Data:t?`${t.substring(0,50)}...`:null,mimeType:n,x:r,y:o,width:s,height:i,name:c,parentId:d,cornerRadius:l,scaleMode:a}),!t)throw new Error("Base64 image data is required");try{console.log("Step 1: Creating rectangle container");const h=figma.createRectangle();h.x=r,h.y=o,h.resize(s,i),h.name=c,l>0&&(h.cornerRadius=l),console.log("Step 2: Converting base64 to bytes"),console.log("Base64 data length:",t.length);const f=le(t);console.log("Converted bytes length:",f.length),console.log("Step 3: Creating Figma image from bytes");const g=figma.createImage(f);console.log("Image created with hash:",g.hash);const u={type:"IMAGE",scaleMode:a,imageHash:g.hash};console.log("Step 4: Applying image fill to rectangle"),h.fills=[u],console.log("Step 5: Adding to parent node");const m=await O(h,d);return console.log("Step 6: Selecting and focusing"),figma.currentPage.selection=[h],figma.viewport.scrollAndZoomIntoView([h]),console.log("Step 7: Returning result"),G(q({},F(h,m)),{imageHash:g.hash,mimeType:n,scaleMode:a})}catch(h){throw console.error("Error creating image from URL:",h),console.error("Error stack:",h.stack),new Error(`Failed to create image from URL: ${h.message||h}`)}}async function pt(e){const t=e.nodeId||e.Node_ID,n=e.base64Data||e.Base64_Data||e.base64_data,r=e.mimeType||e.Mime_Type||e.mime_type||"image/png",o=e.scaleMode||e.Scale_Mode||e.scale_mode||"FILL";if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Base64 image data is required");try{const s=await v(t);if(!s)throw new Error(`Node not found with ID: ${t}`);if(!("fills"in s))throw new Error(`Node ${t} does not support fills`);const i=s,c=le(n),d=figma.createImage(c),l={type:"IMAGE",scaleMode:o,imageHash:d.hash};return i.fills=[l],figma.currentPage.selection=[s],figma.viewport.scrollAndZoomIntoView([s]),{success:!0,nodeId:s.id,name:s.name,type:s.type,imageHash:d.hash,mimeType:r,scaleMode:o}}catch(s){throw console.error("Error replacing image:",s),new Error(`Failed to replace image: ${s.message||s}`)}}async function ae(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Union";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean union");try{const r=[];for(const s of t){const i=await v(s);if(!i)throw new Error(`Node not found with ID: ${s}`);if(!H(i))throw new Error(`Node '${s}' cannot be used in boolean operations`);r.push(i)}const o=figma.union(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"UNION",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean union:",r),new Error(`Failed to create boolean union: ${r.message||r}`)}}async function fe(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Subtract";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean subtract");try{const r=[];for(const s of t){const i=await v(s);if(!i)throw new Error(`Node not found with ID: ${s}`);if(!H(i))throw new Error(`Node '${s}' cannot be used in boolean operations`);r.push(i)}const o=figma.subtract(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"SUBTRACT",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean subtract:",r),new Error(`Failed to create boolean subtract: ${r.message||r}`)}}async function ue(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Intersect";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean intersect");try{const r=[];for(const s of t){const i=await v(s);if(!i)throw new Error(`Node not found with ID: ${s}`);if(!H(i))throw new Error(`Node '${s}' cannot be used in boolean operations`);r.push(i)}const o=figma.intersect(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"INTERSECT",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean intersect:",r),new Error(`Failed to create boolean intersect: ${r.message||r}`)}}async function ge(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Exclude";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean exclude");try{const r=[];for(const s of t){const i=await v(s);if(!i)throw new Error(`Node not found with ID: ${s}`);if(!H(i))throw new Error(`Node '${s}' cannot be used in boolean operations`);r.push(i)}const o=figma.exclude(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"EXCLUDE",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean exclude:",r),new Error(`Failed to create boolean exclude: ${r.message||r}`)}}async function wt(e){const t=e.operation||e.Operation||e.type;if(!t)throw new Error("Operation type is required");switch(t.toUpperCase()){case"UNION":return await ae(e);case"SUBTRACT":return await fe(e);case"INTERSECT":return await ue(e);case"EXCLUDE":return await ge(e);default:throw new Error(`Invalid boolean operation: ${t}. Must be UNION, SUBTRACT, INTERSECT, or EXCLUDE`)}}async function mt(e){try{const t=figma.root.children.map(o=>({id:o.id,name:o.name,type:o.type})),n=figma.currentPage,r=figma.currentPage.selection.map(o=>({id:o.id,name:o.name,type:o.type}));return{success:!0,document:{name:figma.root.name,id:figma.root.id,type:figma.root.type},pages:t,currentPage:{id:n.id,name:n.name,type:n.type},selection:r,selectionCount:r.length,editorType:figma.editorType,totalPages:t.length}}catch(t){throw console.error("Error getting document info:",t),new Error(`Failed to get document info: ${t.message||t}`)}}async function It(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r={id:n.id,name:n.name,type:n.type,visible:n.visible};if("x"in n&&"y"in n&&(r.x=n.x,r.y=n.y),"width"in n&&"height"in n&&(r.width=n.width,r.height=n.height),"rotation"in n&&(r.rotation=n.rotation),"opacity"in n&&(r.opacity=n.opacity),"fills"in n&&(r.fills=n.fills),"strokes"in n&&(r.strokes=n.strokes,"strokeWeight"in n&&(r.strokeWeight=n.strokeWeight)),"cornerRadius"in n&&(r.cornerRadius=n.cornerRadius),n.type==="TEXT"){const o=n;r.characters=o.characters,r.fontSize=o.fontSize,r.fontName=o.fontName,r.textAlignHorizontal=o.textAlignHorizontal,r.textAlignVertical=o.textAlignVertical,r.letterSpacing=o.letterSpacing,r.lineHeight=o.lineHeight}if(n.type==="FRAME"){const o=n;r.layoutMode=o.layoutMode,r.itemSpacing=o.itemSpacing,r.paddingLeft=o.paddingLeft,r.paddingRight=o.paddingRight,r.paddingTop=o.paddingTop,r.paddingBottom=o.paddingBottom,r.clipsContent=o.clipsContent}if("children"in n){const o=n;r.childrenCount=o.children.length,r.children=o.children.map(s=>({id:s.id,name:s.name,type:s.type}))}return n.parent&&(r.parent={id:n.parent.id,name:n.parent.name,type:n.parent.type}),{success:!0,nodeInfo:r}}catch(n){throw console.error("Error getting node info:",n),new Error(`Failed to get node info: ${n.message||n}`)}}async function Nt(e){try{const t=figma.currentPage.selection;if(t.length===0)return{success:!0,selection:[],selectionCount:0,message:"No nodes selected"};const n=t.map(r=>{const o={id:r.id,name:r.name,type:r.type,visible:r.visible};return"x"in r&&"y"in r&&(o.x=r.x,o.y=r.y),"width"in r&&"height"in r&&(o.width=r.width,o.height=r.height),o});return{success:!0,selection:n,selectionCount:t.length,firstSelected:n[0]}}catch(t){throw console.error("Error getting selection:",t),new Error(`Failed to get selection: ${t.message||t}`)}}async function Et(e){const t=e.query||e.Query,n=e.nodeType||e.Node_Type,r=e.limit||e.Limit||50;if(!t&&!n)throw new Error("Either query or nodeType is required");try{let o=[];n?o=figma.currentPage.findAll(c=>c.type===n.toUpperCase()):o=figma.currentPage.findAll(c=>c.name.toLowerCase().includes(t.toLowerCase()));const s=o.slice(0,r);return{success:!0,searchResults:s.map(c=>{const d={id:c.id,name:c.name,type:c.type,visible:c.visible};return"x"in c&&"y"in c&&(d.x=c.x,d.y=c.y),"width"in c&&"height"in c&&(d.width=c.width,d.height=c.height),d}),totalFound:o.length,returned:s.length,query:t,nodeType:n}}catch(o){throw console.error("Error searching nodes:",o),new Error(`Failed to search nodes: ${o.message||o}`)}}async function vt(e){const t=e.pageId||e.Page_ID;try{let n;if(t){const i=await v(t);if(!i||i.type!=="PAGE")throw new Error(`Page not found with ID: ${t}`);n=i}else n=figma.currentPage;const r=n.findAll(),o=r.reduce((i,c)=>(i[c.type]=(i[c.type]||0)+1,i),{}),s=n.children.map(i=>({id:i.id,name:i.name,type:i.type,visible:i.visible}));return{success:!0,page:{id:n.id,name:n.name,type:n.type},statistics:{totalNodes:r.length,topLevelNodes:n.children.length,nodeTypes:o},topLevelNodes:s}}catch(n){throw console.error("Error getting page info:",n),new Error(`Failed to get page info: ${n.message||n}`)}}async function bt(e){const t=e.nodeId||e.Node_ID,n=e.format||e.Format||"PNG",r=e.scale||e.Scale||1;if(!t)throw new Error("Node ID is required");try{const o=await v(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("exportAsync"in o))throw new Error(`Node ${t} cannot be exported`);const s=o,i={format:n.toUpperCase(),constraint:{type:"SCALE",value:r}},c=await s.exportAsync(i);let d="";const l=new Uint8Array(c);for(let h=0;h<l.length;h++)d+=String.fromCharCode(l[h]);const a=btoa(d);return{success:!0,nodeId:o.id,name:o.name,type:o.type,format:n,scale:r,imageData:a,size:c.byteLength}}catch(o){throw console.error("Error exporting node as image:",o),new Error(`Failed to export node as image: ${o.message||o}`)}}async function _t(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(!t||!t.length)throw new Error("Node IDs are required");typeof t=="string"&&(t=t.split(",").map(n=>n.trim()).filter(n=>n.length>0)),Array.isArray(t)||(t=[t]);try{const n=[],r=[];for(const o of t)try{const s=await v(o);if(!s){r.push({id:o,error:"Node not found"});continue}const i={id:s.id,name:s.name,type:s.type,visible:s.visible};if("x"in s&&"y"in s&&(i.x=s.x,i.y=s.y),"width"in s&&"height"in s&&(i.width=s.width,i.height=s.height),"rotation"in s&&(i.rotation=s.rotation),"opacity"in s&&(i.opacity=s.opacity),"fills"in s&&(i.fills=s.fills),"strokes"in s&&(i.strokes=s.strokes,"strokeWeight"in s&&(i.strokeWeight=s.strokeWeight)),s.type==="TEXT"){const c=s;i.characters=c.characters,i.fontSize=c.fontSize,i.fontName=c.fontName}s.parent&&(i.parentId=s.parent.id,i.parentName=s.parent.name,i.parentType=s.parent.type),"children"in s&&(i.childrenCount=s.children.length),n.push(i)}catch(s){r.push({id:o,error:s.message||"Unknown error"})}return{success:!0,nodes:n,foundCount:n.length,errors:r.length>0?r:void 0,totalRequested:t.length}}catch(n){throw console.error("Error getting multiple nodes info:",n),new Error(`Failed to get multiple nodes info: ${n.message||n}`)}}async function xt(e){var o,s,i;const t=e.searchLocal!==!1,n=e.searchRemote||!1,r=e.includeVariants||!1;try{const c=[];if(t){await figma.loadAllPagesAsync();const a=figma.root.findAll(h=>r?h.type==="COMPONENT"||h.type==="COMPONENT_SET":h.type==="COMPONENT");for(const h of a)if(h.type==="COMPONENT"){const f=h;let g=f,u="Unknown",m="";for(;g&&g.type!=="PAGE";)g=g.parent;g&&g.type==="PAGE"&&(u=g.name,m=g.id);const y={id:f.id,key:f.key,name:f.name,description:f.description,type:"COMPONENT",pageName:u,pageId:m,remote:!1};try{if(((o=f.parent)==null?void 0:o.type)!=="COMPONENT_SET"&&f.componentPropertyDefinitions){y.properties={};for(const[w,p]of Object.entries(f.componentPropertyDefinitions))y.properties[w]={type:p.type,defaultValue:p.defaultValue,variantOptions:p.variantOptions}}if(((s=f.parent)==null?void 0:s.type)==="COMPONENT_SET"){const w=f.parent;if(w.componentPropertyDefinitions){y.properties={},y.isVariant=!0,y.parentSetId=w.id,y.parentSetName=w.name;for(const[p,I]of Object.entries(w.componentPropertyDefinitions))y.properties[p]={type:I.type,defaultValue:I.defaultValue,variantOptions:I.variantOptions};if(f.name){y.variantProperties={};const p=f.name.split(",").map(I=>I.trim());for(const I of p){const[E,N]=I.split("=").map(b=>b.trim());E&&N&&(y.variantProperties[E]=N)}}}}}catch(w){console.warn(`Error getting properties for component ${f.id}:`,w)}c.push(y)}else if(h.type==="COMPONENT_SET"&&r){const f=h;let g=f,u="Unknown",m="";for(;g&&g.type!=="PAGE";)g=g.parent;g&&g.type==="PAGE"&&(u=g.name,m=g.id);const y={id:f.id,key:f.key,name:f.name,description:f.description,type:"COMPONENT_SET",pageName:u,pageId:m,remote:!1,defaultVariantId:(i=f.defaultVariant)==null?void 0:i.id};if(f.componentPropertyDefinitions){y.properties={};for(const[w,p]of Object.entries(f.componentPropertyDefinitions))y.properties[w]={type:p.type,defaultValue:p.defaultValue,variantOptions:p.variantOptions}}f.variantGroupProperties&&(y.variantGroupProperties=f.variantGroupProperties),c.push(y)}}n&&console.log("Remote component search is not currently supported");const d={};for(const a of c)a.pageId&&(d[a.pageId]||(d[a.pageId]={pageName:a.pageName,componentCount:0}),d[a.pageId].componentCount++);const l=figma.root.children.map(a=>({id:a.id,name:a.name,type:a.type}));return{success:!0,components:c,totalFound:c.length,searchLocal:t,searchRemote:n,includeVariants:r,pages:l,pagesSummary:d,documentName:figma.root.name}}catch(c){throw console.error("Error getting components:",c),new Error(`Failed to get components: ${c.message||c}`)}}async function Ct(e){let t=e.nodeTypes||e.Node_Types||["TEXT"];const n=e.nodeId||e.Node_ID||null,r=e.limit||e.Limit||100;typeof t=="string"&&(t=t.split(",").map(o=>o.trim().toUpperCase()).filter(o=>o.length>0)),Array.isArray(t)||(t=[t]),t=t.map(o=>o.toUpperCase());try{let o=function(l){if(t.includes(l.type)&&i.push(l),"children"in l)for(const a of l.children)o(a)},s;if(n){const l=await v(n);if(!l)throw new Error(`Node not found with ID: ${n}`);s=l}else s=figma.currentPage;const i=[];o(s);const c=i.slice(0,r);return{success:!0,nodes:c.map(l=>{const a={id:l.id,name:l.name,type:l.type,visible:l.visible};if("x"in l&&"y"in l&&(a.x=l.x,a.y=l.y),"width"in l&&"height"in l&&(a.width=l.width,a.height=l.height),l.type==="TEXT"){const h=l;a.characters=h.characters}return l.parent&&(a.parentId=l.parent.id,a.parentName=l.parent.name,a.parentType=l.parent.type),a}),totalFound:i.length,returned:c.length,nodeTypes:t,searchScope:n||"current page"}}catch(o){throw console.error("Error scanning nodes by types:",o),new Error(`Failed to scan nodes by types: ${o.message||o}`)}}async function ne(e){let t=[],n=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(typeof n=="string"&&(n=n.split(",").map(y=>y.trim()).filter(y=>y.length>0)),Array.isArray(n)||(n=[n]),n&&n.length>0){const y=[];for(const w of n)try{const p=await v(w);p&&"x"in p&&y.push(p)}catch(p){console.warn(`Node not found: ${w}`)}t=y}else t=figma.currentPage.selection;if(!t||t.length===0)throw new Error("No nodes found. Please select nodes or provide valid node IDs.");const r=e.fillColor||e.Fill_Color,o=e.strokeColor||e.Stroke_Color,s=e.strokeWeight!==void 0?Number(e.strokeWeight):e.Stroke_Weight,i=e.strokeAlign||e.Stroke_Align||"INSIDE",c=e.opacity!==void 0?Number(e.opacity):e.Opacity,d=e.cornerRadius!==void 0?Number(e.cornerRadius):e.Corner_Radius,l=e.addDropShadow||e.Add_Drop_Shadow||!1,a=e.addInnerShadow||e.Add_Inner_Shadow||!1,h=e.addBlur||e.Add_Blur||!1,f=e.blurRadius!==void 0?Number(e.blurRadius):e.Blur_Radius||4,g=[];for(const y of t){const w=[];try{if(r&&"fills"in y){const p=S(r);y.fills=[p],w.push("fillColor")}if((o||s!==void 0)&&"strokes"in y){if(o){const p=S(o);y.strokes=[p],w.push("strokeColor")}s!==void 0&&"strokeWeight"in y&&(y.strokeWeight=s,w.push("strokeWeight")),i&&"strokeAlign"in y&&(y.strokeAlign=i,w.push("strokeAlign"))}if(c!==void 0&&"opacity"in y&&(y.opacity=Math.max(0,Math.min(1,c)),w.push("opacity")),d!==void 0&&"cornerRadius"in y&&(y.cornerRadius=Math.max(0,d),w.push("cornerRadius")),"effects"in y&&(l||a||h)){const p=[...y.effects||[]];l&&(p.push({type:"DROP_SHADOW",color:{r:0,g:0,b:0,a:.25},offset:{x:0,y:4},radius:4,spread:0,visible:!0,blendMode:"NORMAL"}),w.push("dropShadow")),a&&(p.push({type:"INNER_SHADOW",color:{r:0,g:0,b:0,a:.25},offset:{x:0,y:4},radius:4,spread:0,visible:!0,blendMode:"NORMAL"}),w.push("innerShadow")),h&&(p.push({type:"LAYER_BLUR",radius:f,visible:!0}),w.push("blur")),y.effects=p}g.push({nodeId:y.id,name:y.name,type:y.type,appliedStyles:w})}catch(p){g.push({nodeId:y.id,name:y.name,type:y.type,appliedStyles:[],error:p.message||"Unknown error"})}}const u=g.filter(y=>!y.error).length,m=g.reduce((y,w)=>y+w.appliedStyles.length,0);return{success:!0,results:g,targetCount:t.length,successCount:u,failureCount:t.length-u,totalStylesApplied:m}}async function At(e){let t=[],n=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(typeof n=="string"&&(n=n.split(",").map(u=>u.trim()).filter(u=>u.length>0)),Array.isArray(n)||(n=[n]),n&&n.length>0){const u=[];for(const m of n)try{const y=await v(m);y&&"x"in y&&u.push(y)}catch(y){console.warn(`Node not found: ${m}`)}t=u}else t=figma.currentPage.selection;if(!t||t.length===0)throw new Error("No nodes found. Please select text nodes or provide valid node IDs.");const r=e.fontSize!==void 0?Number(e.fontSize):e.Font_Size,o=e.fontFamily||e.Font_Family,s=e.fontWeight||e.Font_Weight,i=e.textColor||e.Text_Color||e.fontColor||e.Font_Color,c=e.textAlign||e.Text_Align||e.textAlignHorizontal,d=e.letterSpacing!==void 0?Number(e.letterSpacing):e.Letter_Spacing,l=e.lineHeight!==void 0?Number(e.lineHeight):e.Line_Height,a=[];for(const u of t){const m=[];try{if(u.type!=="TEXT"){a.push({nodeId:u.id,name:u.name,type:u.type,appliedStyles:[],error:"Not a text node"});continue}const y=u;if(o||s!==void 0){const w=o||(y.fontName!==figma.mixed?y.fontName.family:"Inter"),p=s?St(s):y.fontName!==figma.mixed?y.fontName.style:"Regular";try{await figma.loadFontAsync({family:w,style:p}),y.fontName={family:w,style:p},m.push("font")}catch(I){await figma.loadFontAsync({family:"Inter",style:"Regular"}),y.fontName={family:"Inter",style:"Regular"},m.push("font (fallback)")}}if(r!==void 0&&(y.fontSize=r,m.push("fontSize")),i){const w=S(i);y.fills=[w],m.push("textColor")}c&&(y.textAlignHorizontal=c,m.push("textAlign")),d!==void 0&&(y.letterSpacing={value:d,unit:"PIXELS"},m.push("letterSpacing")),l!==void 0&&(y.lineHeight={value:l,unit:"PIXELS"},m.push("lineHeight")),a.push({nodeId:u.id,name:u.name,type:u.type,appliedStyles:m})}catch(y){a.push({nodeId:u.id,name:u.name,type:u.type,appliedStyles:[],error:y.message||"Unknown error"})}}const h=a.filter(u=>!u.error).length,f=a.filter(u=>u.type==="TEXT").length,g=a.reduce((u,m)=>u+m.appliedStyles.length,0);return{success:!0,results:a,targetCount:t.length,textNodeCount:f,successCount:h,failureCount:t.length-h,totalStylesApplied:g}}function St(e){const t=typeof e=="string"?parseInt(e):e;return!t||t===400?"Regular":t>=900?"Black":t>=800?"Extra Bold":t>=700?"Bold":t>=600?"Semi Bold":t>=500?"Medium":t>=300?"Light":t>=200?"Extra Light":t>=100?"Thin":"Regular"}async function Pt(e){const t=e.nodeId,n=e.targetIndex;if(!t)throw new Error("Node ID is required");if(n===void 0||n<0)throw new Error("Valid target index is required (0 or greater)");const r=await v(t);if(!r)throw new Error(`Node not found with ID: ${t}`);const o=r.parent;if(!o||!("children"in o))throw new Error("Node parent does not support reordering");try{const s=o.children.indexOf(r);if(s===-1)throw new Error("Node not found in parent children");const i=o.children.length-1,c=Math.min(Math.max(0,n),i);return s!==c&&o.insertChild(c,r),{success:!0,nodeId:r.id,name:r.name,type:r.type,previousIndex:s,newIndex:c,message:`Moved layer from index ${s} to ${c}`}}catch(s){throw console.error("Error reordering layer:",s),new Error(`Failed to reorder layer: ${s.message||s}`)}}async function Dt(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("appendChild"in r))throw new Error("Node parent does not support reordering");try{return r.appendChild(n),{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Moved layer to front"}}catch(o){throw console.error("Error moving layer to front:",o),new Error(`Failed to move layer to front: ${o.message||o}`)}}async function kt(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("insertChild"in r))throw new Error("Node parent does not support reordering");try{return r.insertChild(0,n),{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Moved layer to back"}}catch(o){throw console.error("Error moving layer to back:",o),new Error(`Failed to move layer to back: ${o.message||o}`)}}async function Tt(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("children"in r)||!("insertChild"in r))throw new Error("Node parent does not support reordering");try{const o=r.children.indexOf(n);if(o===-1)throw new Error("Node not found in parent children");if(o===r.children.length-1)return{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Layer is already at the front"};const s=o+1;return r.insertChild(s,n),{success:!0,nodeId:n.id,name:n.name,type:n.type,previousIndex:o,newIndex:s,message:`Moved layer forward from index ${o} to ${s}`}}catch(o){throw console.error("Error moving layer forward:",o),new Error(`Failed to move layer forward: ${o.message||o}`)}}async function Ot(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await v(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("children"in r)||!("insertChild"in r))throw new Error("Node parent does not support reordering");try{const o=r.children.indexOf(n);if(o===-1)throw new Error("Node not found in parent children");if(o===0)return{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Layer is already at the back"};const s=o-1;return r.insertChild(s,n),{success:!0,nodeId:n.id,name:n.name,type:n.type,previousIndex:o,newIndex:s,message:`Moved layer backward from index ${o} to ${s}`}}catch(o){throw console.error("Error moving layer backward:",o),new Error(`Failed to move layer backward: ${o.message||o}`)}}async function Ft(e){const t=e.parentNodeId,n=e.sortOrder||"ascending",r=e.caseSensitive!==!1;let o;if(t){const s=await v(t);if(!s)throw new Error(`Parent node not found with ID: ${t}`);if(!("children"in s))throw new Error("Specified node does not support children");o=s}else o=figma.currentPage;try{const s=[...o.children];return s.sort((i,c)=>{const d=r?i.name:i.name.toLowerCase(),l=r?c.name:c.name.toLowerCase();return n==="descending"?l.localeCompare(d):d.localeCompare(l)}),s.forEach((i,c)=>{o.insertChild(c,i)}),{success:!0,parentNodeId:o.id,parentNodeName:o.name,sortedCount:s.length,sortOrder:n,caseSensitive:r,message:`Sorted ${s.length} layers by name (${n})`}}catch(s){throw console.error("Error sorting layers by name:",s),new Error(`Failed to sort layers by name: ${s.message||s}`)}}async function Mt(e){const t=e.parentNodeId,n=e.sortBy||"x",r=e.sortOrder||"ascending";let o;if(t){const s=await v(t);if(!s)throw new Error(`Parent node not found with ID: ${t}`);if(!("children"in s))throw new Error("Specified node does not support children");o=s}else o=figma.currentPage;try{const s=o.children.filter(i=>"x"in i&&"y"in i);return s.sort((i,c)=>{let d=0;switch(n){case"x":d=i.x-c.x;break;case"y":d=i.y-c.y;break;case"xy":d=i.y-c.y,d===0&&(d=i.x-c.x);break}return r==="descending"?-d:d}),s.forEach((i,c)=>{o.insertChild(c,i)}),{success:!0,parentNodeId:o.id,parentNodeName:o.name,sortedCount:s.length,totalChildren:o.children.length,sortBy:n,sortOrder:r,message:`Sorted ${s.length} positioned layers by ${n} (${r})`}}catch(s){throw console.error("Error sorting layers by position:",s),new Error(`Failed to sort layers by position: ${s.message||s}`)}}async function $t(e){const t=e.nodeIds,n=e.startIndex||0;if(!t||!Array.isArray(t)||t.length===0)throw new Error("Node IDs array is required");try{const r=[];let o=null;for(const i of t){const c=await v(i);if(!c)throw new Error(`Node not found with ID: ${i}`);if(o){if(c.parent!==o)throw new Error("All nodes must have the same parent")}else if(o=c.parent,!o||!("children"in o))throw new Error("Node parent does not support reordering");r.push(c)}let s=Math.max(0,Math.min(n,o.children.length-r.length));for(const i of r)o.insertChild(s,i),s++;return{success:!0,reorderedCount:r.length,parentNodeId:o.id,parentNodeName:o.name,startIndex:Math.max(0,Math.min(n,o.children.length-r.length)),message:`Reordered ${r.length} layers starting at index ${s-r.length}`}}catch(r){throw console.error("Error reordering multiple layers:",r),new Error(`Failed to reorder multiple layers: ${r.message||r}`)}}const L={serverPort:3055,channelId:"hellofigma",isConnected:!1};function Rt(){figma.showUI(__html__,{width:300,height:380,themeColors:!0}),Lt(),figma.ui.onmessage=async e=>{if(!e||typeof e.type!="string"){figma.notify("Invalid message received from UI",{error:!0});return}switch(e.type){case"execute-command":zt(e);break;case"update-settings":Bt(e);break;case"notify":if(e.message){const t={timeout:e.timeout||3e3,error:e.error||!1};figma.notify(e.message,t)}else figma.notify("Empty notification message received",{error:!0});break;case"copy-to-clipboard":try{e.text&&(figma.ui.postMessage({type:"execute-copy",text:e.text}),figma.notify(`Copied: ${e.text}`,{timeout:2e3}))}catch(t){console.error("❌ Failed to copy to clipboard:",t),figma.notify("Failed to copy to clipboard",{error:!0})}break;case"close-plugin":try{await figma.clientStorage.setAsync("lastSession",{timestamp:new Date().toISOString(),selectionCount:figma.currentPage.selection.length}),figma.closePlugin("👋 Figmation session ended. Thanks for using Figmation!")}catch(t){console.warn("Error during plugin cleanup:",t),figma.closePlugin()}break;default:console.warn("Unknown message type received from UI:",e.type);break}}}async function Lt(){try{const e=await figma.clientStorage.getAsync("serverSettings");e&&(L.serverPort=e.serverPort||3055,L.channelId=e.channelId||"hellofigma",console.log("✅ Loaded saved settings:",e),figma.ui.postMessage({type:"settings-loaded",settings:{serverPort:L.serverPort,channelId:L.channelId}}));const t=Ee(L.serverPort,L.channelId);t.setMessageHandler(Vt),t.connect(),re(),figma.on("selectionchange",re)}catch(e){console.error("❌ Plugin initialization failed:",e),figma.notify("Plugin initialization failed. Check console for details.",{error:!0})}}async function Vt(e){try{if(console.log("📨 Received WebSocket message:",e),!e.command)throw new Error("No command specified in message");const t=await he(e.command,e.parameters||{}),n={command:e.command,serverId:e.serverId,result:t,timestamp:new Date().toISOString(),success:!0};figma.ui.postMessage({type:"websocket-send",data:n}),console.log("✅ Command executed successfully:",e.command)}catch(t){console.error("❌ Command execution error:",t);const n=t instanceof Error?t.message:"Unknown error occurred",r={command:e.command,serverId:e.serverId,error:n,timestamp:new Date().toISOString(),success:!1};figma.ui.postMessage({type:"websocket-send",data:r}),figma.notify(`Command failed: ${n}`,{error:!0})}}async function zt(e){try{console.log("🔧 Executing UI command:",e.command,e.params);const t=await he(e.command,e.params||{});figma.ui.postMessage({type:"command-result",id:e.id,result:t}),console.log("✅ UI command executed successfully:",e.command)}catch(t){console.error("❌ UI command execution error:",t);const n=t instanceof Error?t.message:"Unknown error occurred";figma.ui.postMessage({type:"command-error",id:e.id,error:n})}}async function he(e,t){const r={create_rectangle:_e,create_ellipse:be,create_circle:xe,create_line:Ce,create_star:Ae,create_polygon:Se,create_vector_path:Pe,create_text:De,update_text:ke,set_text_content:ce,set_font:Te,scan_text_nodes:Oe,set_multiple_text_contents:Fe,search_available_fonts:Me,set_fill_color:$e,set_stroke_color:Re,set_opacity:Le,apply_effect:Ve,set_corner_radius:ze,set_individual_corner_radius:Be,create_frame:We,create_auto_layout:Ue,create_instance:qe,create_component:Ye,set_layout_grid:Xe,set_layout_mode:He,set_padding:Ze,set_item_spacing:je,set_axis_align:Je,set_layout_sizing:Ke,set_annotation:Qe,get_annotations:et,move_node:tt,resize_node:ot,rotate_node:de,set_rotation:nt,delete_node:rt,delete_multiple_nodes:at,clone_node:it,group_nodes:oe,create_group:oe,get_instance_overrides:ft,set_instance_overrides:ut,detach_instance:gt,ungroup_node:st,select_nodes:ct,select_nodes_by_type:dt,select_nodes_by_name:lt,create_design_from_svg:ht,create_image_from_url:yt,replace_image:pt,boolean_union:ae,boolean_subtract:fe,boolean_intersect:ue,boolean_exclude:ge,create_boolean_operation:wt,get_document_info:mt,get_node_info:It,get_nodes_info:_t,get_selection:Nt,search_nodes:Et,get_page_info:vt,export_node_as_image:bt,get_components:xt,scan_nodes_by_types:Ct,apply_styles_to_selection:ne,apply_text_styles_to_selection:At,apply_styles_to_nodes:ne,reorder_layer:Pt,move_to_front:Dt,move_to_back:kt,move_forward:Tt,move_backward:Ot,sort_layers_by_name:Ft,sort_layers_by_position:Mt,reorder_multiple_layers:$t}[e];if(!r)throw new Error(`Unknown command: ${e}`);return await r(t)}async function Bt(e){try{if(e.serverPort&&(isNaN(e.serverPort)||e.serverPort<1||e.serverPort>65535))throw new Error("Invalid server port. Must be a number between 1 and 65535.");if(e.channelId&&typeof e.channelId!="string")throw new Error("Invalid channel ID. Must be a string.");e.serverPort&&(L.serverPort=parseInt(e.serverPort)),e.channelId&&(L.channelId=e.channelId.trim()),await figma.clientStorage.setAsync("serverSettings",{serverPort:L.serverPort,channelId:L.channelId,lastUpdated:new Date().toISOString()}),console.log("✅ Settings updated and saved:",{serverPort:L.serverPort,channelId:L.channelId}),figma.ui.postMessage({type:"settings-saved",settings:{serverPort:L.serverPort,channelId:L.channelId}}),figma.notify("Settings saved successfully!",{timeout:2e3})}catch(t){console.error("❌ Settings update failed:",t);const n=t instanceof Error?t.message:"Unknown error occurred";figma.ui.postMessage({type:"settings-error",error:n}),figma.notify(`Settings update failed: ${n}`,{error:!0})}}async function re(){try{const e=figma.currentPage.selection,t={count:e.length,nodes:await Promise.all(e.map(async n=>{var o,s;const r={id:n.id,name:n.name,type:n.type,x:"x"in n?n.x:0,y:"y"in n?n.y:0,width:"width"in n?n.width:0,height:"height"in n?n.height:0,visible:n.visible,locked:n.locked,opacity:"opacity"in n?n.opacity:1,blendMode:"blendMode"in n?n.blendMode:"NORMAL"};if(n.type==="COMPONENT"||n.type==="COMPONENT_SET"){if(r.isComponentSet=n.type==="COMPONENT_SET",n.type==="COMPONENT"){const i=n;r.key=i.key,r.description=i.description,r.documentationLinks=i.documentationLinks||[];try{if(((o=i.parent)==null?void 0:o.type)==="COMPONENT_SET"){const d=i.parent.componentPropertyDefinitions;r.componentProperties=Object.entries(d).map(([l,a])=>({key:l,type:a.type,defaultValue:a.defaultValue,variantOptions:a.type==="VARIANT"?a.variantOptions:void 0}))}else{const c=i.componentPropertyDefinitions;r.componentProperties=Object.entries(c).map(([d,l])=>({key:d,type:l.type,defaultValue:l.defaultValue,variantOptions:l.type==="VARIANT"?l.variantOptions:void 0}))}}catch(c){console.warn("Error getting component properties:",c),r.componentProperties=[]}}if(n.type==="COMPONENT_SET"){const i=n;r.key=i.key,r.description=i.description,r.documentationLinks=i.documentationLinks||[],r.variantGroupProperties=i.variantGroupProperties||{};try{const c=i.componentPropertyDefinitions;r.componentProperties=Object.entries(c).map(([d,l])=>({key:d,type:l.type,defaultValue:l.defaultValue,variantOptions:l.type==="VARIANT"?l.variantOptions:void 0}))}catch(c){console.warn("Error getting component set properties:",c),r.componentProperties=[]}}}if(n.type==="INSTANCE"){const i=n;try{const c=await i.getMainComponentAsync();r.mainComponent=c?{id:c.id,name:c.name,key:c.key}:null;const d=i.componentProperties;if(d&&Object.keys(d).length>0&&(r.componentProperties=d),c)try{let l={};if(((s=c.parent)==null?void 0:s.type)==="COMPONENT_SET"){const a=c.parent;a.componentPropertyDefinitions&&(l=a.componentPropertyDefinitions)}else c.componentPropertyDefinitions&&(l=c.componentPropertyDefinitions);Object.keys(l).length>0&&(r.availableProperties=Object.entries(l).map(([a,h])=>({key:a,type:h.type,defaultValue:h.defaultValue,currentValue:d==null?void 0:d[a],variantOptions:h.type==="VARIANT"?h.variantOptions:void 0})))}catch(l){console.warn("Error getting available properties:",l)}try{const l=i.exposedInstances||[];r.exposedInstances=l.map(a=>({name:a.name,type:a.type}))}catch(l){console.warn("Error getting exposed instances:",l)}}catch(c){console.warn("Error getting instance info:",c)}}if(n.type==="TEXT"){const i=n;r.characters=i.characters,r.fontSize=i.fontSize,r.fontName=i.fontName,r.textAlignHorizontal=i.textAlignHorizontal,r.textAlignVertical=i.textAlignVertical}return"layoutMode"in n&&(r.layoutMode=n.layoutMode,n.layoutMode!=="NONE"&&(r.layoutDirection="layoutDirection"in n?n.layoutDirection:null,r.itemSpacing=n.itemSpacing,r.paddingLeft=n.paddingLeft,r.paddingRight=n.paddingRight,r.paddingTop=n.paddingTop,r.paddingBottom=n.paddingBottom)),"fills"in n&&n.fills!==figma.mixed&&(r.fillsCount=Array.isArray(n.fills)?n.fills.length:0),"strokes"in n&&(r.strokesCount=Array.isArray(n.strokes)?n.strokes.length:0,r.strokeWeight=n.strokeWeight),"effects"in n&&(r.effectsCount=Array.isArray(n.effects)?n.effects.length:0,n.effects.length>0&&(r.effectTypes=n.effects.map(i=>i.type))),"constraints"in n&&(r.constraints=n.constraints),r}))};figma.ui.postMessage({type:"selection-changed",selection:t})}catch(e){console.error("Error updating selection info:",e)}}Rt();
