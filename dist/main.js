"use strict";var we=Object.defineProperty,pe=Object.defineProperties;var Ie=Object.getOwnPropertyDescriptors;var te=Object.getOwnPropertySymbols;var me=Object.prototype.hasOwnProperty,Ne=Object.prototype.propertyIsEnumerable;var K=(e,t,n)=>t in e?we(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,q=(e,t)=>{for(var n in t||(t={}))me.call(t,n)&&K(e,n,t[n]);if(te)for(var n of te(t))Ne.call(t,n)&&K(e,n,t[n]);return e},G=(e,t)=>pe(e,Ie(t));var U=(e,t,n)=>K(e,typeof t!="symbol"?t+"":t,n);function Ee(e,t){const n=`ws://localhost:${e}`,r=new ve(n);return{connect:()=>r.connect(t),disconnect:()=>r.disconnect(),isConnected:()=>r.isConnected(),onMessage:null,onConnectionChange:null,setMessageHandler:o=>{r.onCommand(o)}}}class ve{constructor(t){U(this,"ws",null);U(this,"reconnectInterval",5e3);U(this,"maxReconnectInterval",3e4);U(this,"reconnectDecay",1.5);U(this,"reconnectAttempts",0);U(this,"url");U(this,"channelId",null);U(this,"serverId",null);U(this,"messageHandlers",new Map);this.url=t}connect(t){t&&(this.channelId=t);try{this.ws=new WebSocket(this.url),this.ws.onopen=()=>{console.log("WebSocket connected"),this.reconnectAttempts=0,this.send({type:"register",channelId:this.channelId}),setInterval(()=>{var n;((n=this.ws)==null?void 0:n.readyState)===WebSocket.OPEN&&this.send({type:"ping"})},3e4)},this.ws.onmessage=n=>{try{const r=JSON.parse(n.data);this.handleMessage(r)}catch(r){console.error("Failed to parse WebSocket message:",r)}},this.ws.onclose=()=>{console.log("WebSocket disconnected"),this.reconnect()},this.ws.onerror=n=>{console.error("WebSocket error:",n)}}catch(n){console.error("Failed to create WebSocket:",n),this.reconnect()}}handleMessage(t){switch(t.type){case"channel_assigned":this.channelId=t.channelId,this.serverId=t.serverId,console.log(`Connected to channel: ${this.channelId}`);break;case"command":const n=this.messageHandlers.get("command");n&&n(t);break;case"pong":break;default:console.log("Unknown message type:",t.type)}}onCommand(t){this.messageHandlers.set("command",t)}send(t){var n;((n=this.ws)==null?void 0:n.readyState)===WebSocket.OPEN?this.ws.send(JSON.stringify(t)):console.warn("WebSocket not connected")}reconnect(){if(this.reconnectAttempts>=10){console.error("Max reconnection attempts reached");return}const t=Math.min(this.reconnectInterval*Math.pow(this.reconnectDecay,this.reconnectAttempts),this.maxReconnectInterval);this.reconnectAttempts++,console.log(`Reconnecting in ${t/1e3} seconds...`),setTimeout(()=>{console.log("Attempting to reconnect..."),this.connect()},t)}disconnect(){this.ws&&(this.ws.close(),this.ws=null)}getChannelId(){return this.channelId}getServerId(){return this.serverId}isConnected(){var t;return((t=this.ws)==null?void 0:t.readyState)===WebSocket.OPEN}}function ie(e){const t=e.replace("#","");if(t.length===3){const n=parseInt(t[0]+t[0],16)/255,r=parseInt(t[1]+t[1],16)/255,o=parseInt(t[2]+t[2],16)/255;return{r:n,g:r,b:o,a:1}}else if(t.length===6){const n=parseInt(t.substring(0,2),16)/255,r=parseInt(t.substring(2,4),16)/255,o=parseInt(t.substring(4,6),16)/255;return{r:n,g:r,b:o,a:1}}else if(t.length===8){const n=parseInt(t.substring(0,2),16)/255,r=parseInt(t.substring(2,4),16)/255,o=parseInt(t.substring(4,6),16)/255,i=parseInt(t.substring(6,8),16)/255;return{r:n,g:r,b:o,a:i}}return{r:0,g:0,b:0,a:1}}function B(e){if(e.startsWith("#"))return ie(e);if(e.startsWith("rgba(")){const n=e.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);if(n)return{r:parseInt(n[1])/255,g:parseInt(n[2])/255,b:parseInt(n[3])/255,a:parseFloat(n[4])}}if(e.startsWith("rgb(")){const n=e.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);if(n)return{r:parseInt(n[1])/255,g:parseInt(n[2])/255,b:parseInt(n[3])/255,a:1}}const t={white:{r:1,g:1,b:1,a:1},black:{r:0,g:0,b:0,a:1},red:{r:1,g:0,b:0,a:1},green:{r:0,g:1,b:0,a:1},blue:{r:0,g:0,b:1,a:1},yellow:{r:1,g:1,b:0,a:1},cyan:{r:0,g:1,b:1,a:1},magenta:{r:1,g:0,b:1,a:1},transparent:{r:0,g:0,b:0,a:0}};return t[e.toLowerCase()]?t[e.toLowerCase()]:{r:0,g:0,b:0,a:1}}function A(e){if(typeof e=="string"){const t=B(e);return{type:"SOLID",color:{r:t.r,g:t.g,b:t.b},opacity:t.a!==void 0?t.a:1}}return{type:"SOLID",color:{r:e.r||0,g:e.g||0,b:e.b||0},opacity:e.a!==void 0?e.a:1}}function W(e,t){if(t)return t;const r=figma.currentPage.findAll().filter(o=>o.name.startsWith(e));return`${e} ${r.length+1}`}async function k(e,t){if(t)try{const n=await figma.getNodeByIdAsync(t);if(!n)throw new Error(`Parent node not found with ID: ${t}`);if(!("appendChild"in n))throw new Error(`Parent node does not support children: ${t}`);return n.appendChild(e),t}catch(n){return console.warn("Failed to add to parent, adding to current page:",n.message),figma.currentPage.appendChild(e),null}else return figma.currentPage.appendChild(e),null}function Z(e,t){var n,r,o,i;if(!(!t||typeof t!="object")&&t.addDropShadow){const c={type:"DROP_SHADOW",color:{r:((n=t.shadowColor)==null?void 0:n.r)||0,g:((r=t.shadowColor)==null?void 0:r.g)||0,b:((o=t.shadowColor)==null?void 0:o.b)||0,a:((i=t.shadowColor)==null?void 0:i.a)||.25},offset:{x:t.shadowOffsetX||0,y:t.shadowOffsetY||4},radius:t.shadowRadius||4,spread:t.shadowSpread||0,visible:!0,blendMode:"NORMAL"};e.effects=[c]}}function R(e,t){return{success:!0,nodeId:e.id,id:e.id,name:e.name,type:e.type,x:"x"in e?e.x:0,y:"y"in e?e.y:0,width:"width"in e?e.width:0,height:"height"in e?e.height:0,parentId:t||null}}function H(e){return e&&"x"in e&&"y"in e&&"width"in e&&"height"in e&&"appendChild"in e.parent}function ee(e){return e.replace(/-/g,":")}async function m(e){const t=ee(e);return await figma.getNodeByIdAsync(t)}async function _e(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,i=W("Ellipse",e.name),c=e.initialOpacity!==void 0?Number(e.initialOpacity):1,s=e.initialRotation!==void 0?Number(e.initialRotation):0,d=e.parentIdForNode||e.parentId||null,a=e.startingAngle!==void 0?Number(e.startingAngle):0,l=e.endingAngle!==void 0?Number(e.endingAngle):0,h=e.innerRadius!==void 0?Number(e.innerRadius):0,u=figma.createEllipse();if(u.x=t,u.y=n,u.resize(r,o),u.name=i,u.opacity=c,u.rotation=s,(a!==0||l!==0||h!==0)&&(u.arcData={startingAngle:a,endingAngle:l,innerRadius:h}),e.fillColor||e.Fill_Color_R!==void 0){const f=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};u.fills=[A(f)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const f=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};u.strokes=[A(f)],u.strokeWeight=e.strokeWeight!==void 0?Number(e.strokeWeight):1}e.addDropShadow&&(u.effects=[Z()]);const y=await k(u,d);return figma.currentPage.selection=[u],figma.viewport.scrollAndZoomIntoView([u]),R(u,y)}async function be(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,i=W("Rectangle",e.name),c=e.cornerRadius!==void 0?Number(e.cornerRadius):0,s=e.initialOpacity!==void 0?Number(e.initialOpacity):1,d=e.initialRotation!==void 0?Number(e.initialRotation):0,a=e.parentIdForNode||e.parentId||null,l=figma.createRectangle();if(l.x=t,l.y=n,l.resize(r,o),l.name=i,l.opacity=s,l.rotation=d,c>0&&(l.cornerRadius=c),e.fillColor||e.Fill_Color_R!==void 0){const u=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};l.fills=[A(u)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const u=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};l.strokes=[A(u)],l.strokeWeight=e.strokeWeight||1}Z(l,e);const h=await k(l,a);return figma.currentPage.selection=[l],R(l,h)}async function xe(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.radius!==void 0?Number(e.radius):50,o=W("Circle",e.name),i=e.initialOpacity!==void 0?Number(e.initialOpacity):1,c=e.initialRotation!==void 0?Number(e.initialRotation):0,s=e.parentIdForNode||e.parentId||null,d=figma.createEllipse();if(d.x=t,d.y=n,d.resize(r*2,r*2),d.name=o,d.opacity=i,d.rotation=c,e.fillColor||e.Fill_Color_R!==void 0){const l=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};d.fills=[A(l)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const l=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};d.strokes=[A(l)],d.strokeWeight=e.strokeWeight||1}Z(d,e);const a=await k(d,s);return figma.currentPage.selection=[d],R(d,a)}async function Ce(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x1!==void 0?Number(e.x1):0,n=e.y1!==void 0?Number(e.y1):0,r=e.x2!==void 0?Number(e.x2):100,o=e.y2!==void 0?Number(e.y2):100,i=W("Line",e.name),c=e.parentIdForNode||e.parentId||null,s=Math.min(t,r),d=Math.min(n,o),a=Math.abs(r-t)||1,l=Math.abs(o-n)||1,h=figma.createLine();h.x=s,h.y=d,h.resize(a,l),h.name=i;const u=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};h.strokes=[A(u)],h.strokeWeight=e.strokeWeight||e.Stroke_Weight||1,Z(h,e);const y=await k(h,c);return figma.currentPage.selection=[h],R(h,y)}async function Se(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,i=e.points!==void 0?Number(e.points):5,c=e.innerRadiusRatio!==void 0?Number(e.innerRadiusRatio):.5,s=W("Star",e.name),d=e.parentIdForNode||e.parentId||null,a=figma.createStar();if(a.x=t,a.y=n,a.resize(r,o),a.name=s,a.pointCount=i,a.innerRadius=c,e.fillColor||e.Fill_Color_R!==void 0){const h=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};a.fills=[A(h)]}Z(a,e);const l=await k(a,d);return figma.currentPage.selection=[a],R(a,l)}async function Ae(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,i=e.sides!==void 0?Number(e.sides):6,c=W("Polygon",e.name),s=e.parentIdForNode||e.parentId||null,d=figma.createPolygon();if(d.x=t,d.y=n,d.resize(r,o),d.name=c,d.pointCount=Math.max(3,i),e.fillColor||e.Fill_Color_R!==void 0){const l=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};d.fills=[A(l)]}Z(d,e);const a=await k(d,s);return figma.currentPage.selection=[d],R(d,a)}async function De(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.pathData||e.Path_Data||e.path,o=W("Vector",e.name),i=e.parentIdForNode||e.parentId||null;if(!r)throw new Error("Path data is required for vector path creation");try{const c=figma.createVector();if(c.x=t,c.y=n,c.name=o,c.vectorPaths=[{windingRule:"NONZERO",data:r}],e.fillColor||e.Fill_Color_R!==void 0){const d=e.fillColor||{r:e.Fill_Color_R||0,g:e.Fill_Color_G||0,b:e.Fill_Color_B||0,a:e.Fill_Color_A!==void 0?e.Fill_Color_A:1};c.fills=[A(d)]}if(e.strokeColor||e.Stroke_Color_R!==void 0){const d=e.strokeColor||{r:e.Stroke_Color_R||0,g:e.Stroke_Color_G||0,b:e.Stroke_Color_B||0,a:e.Stroke_Color_A!==void 0?e.Stroke_Color_A:1};c.strokes=[A(d)],c.strokeWeight=e.strokeWeight!==void 0?Number(e.strokeWeight):1}Z(c,e);const s=await k(c,i);return figma.currentPage.selection=[c],figma.viewport.scrollAndZoomIntoView([c]),G(q({},R(c,s)),{pathData:r})}catch(c){throw console.error("Error creating vector path:",c),new Error(`Failed to create vector path: ${c.message||c}`)}}function ce(e){const t=typeof e=="string"?parseInt(e):e;return!t||t===400?"Regular":t>=900?"Black":t>=800?"Extra Bold":t>=700?"Bold":t>=600?"Semi Bold":t>=500?"Medium":t>=300?"Light":t>=200?"Extra Light":t>=100?"Thin":"Regular"}async function Pe(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.textContent||e.text||e.Text_Content||"Hello World",n=e.x!==void 0?Number(e.x):0,r=e.y!==void 0?Number(e.y):0,o=e.fontSize!==void 0?Number(e.fontSize):16,i=e.fontFamily||e.Font_Family||"Inter",c=e.fontWeight||e.Font_Weight;let s=e.textColor||e.Text_Color||e.fontColor||e.Font_Color;!s&&(e.Font_Color_R!==void 0||e.Font_Color_G!==void 0||e.Font_Color_B!==void 0)&&(s={r:e.Font_Color_R!==void 0?e.Font_Color_R:0,g:e.Font_Color_G!==void 0?e.Font_Color_G:0,b:e.Font_Color_B!==void 0?e.Font_Color_B:0,a:e.Font_Color_A!==void 0?e.Font_Color_A:1}),s||(s={r:0,g:0,b:0,a:1});const d=e.backgroundColor||e.Background_Color,a=e.textAlign||e.Text_Align||e.textAlignHorizontal||"LEFT",l=e.letterSpacing||e.Letter_Spacing,h=e.lineHeight||e.Line_Height,u=W("Text",e.name),y=e.parentIdForNode||e.parentId||null;try{const f=figma.createText();f.x=n,f.y=r,f.name=u;const w=ce(c);try{await figma.loadFontAsync({family:i,style:w}),f.fontName={family:i,style:w}}catch(I){console.warn(`Failed to load font ${i} ${w}, falling back to Inter Regular`),await figma.loadFontAsync({family:"Inter",style:"Regular"}),f.fontName={family:"Inter",style:"Regular"}}if(f.fontSize=o,f.characters=t,s){const I=typeof s=="string"?B(s):s;f.fills=[A(I)]}if(d){const I=typeof d=="string"?B(d):d,p=figma.createFrame();p.x=n,p.y=r,p.resize(f.width+20,f.height+10),p.fills=[A(I)],p.name=`${u} Background`,f.x=10,f.y=5,p.appendChild(f);const v=await k(p,y);return figma.currentPage.selection=[p],G(q({},R(p,v)),{textNodeId:f.id})}a&&(f.textAlignHorizontal=a),l!==void 0&&(f.letterSpacing={value:Number(l),unit:"PIXELS"}),h!==void 0&&(f.lineHeight={value:Number(h),unit:"PIXELS"});const g=await k(f,y);return figma.currentPage.selection=[f],R(f,g)}catch(f){throw console.error("Error creating text:",f),new Error(`Failed to create text: ${f.message||f}`)}}async function se(e){const t=e.nodeId||e.Node_ID,n=e.newContent||e.New_Content||e.textContent;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("New content is required");try{const r=await m(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(r.type!=="TEXT")throw new Error(`Node ${t} is not a text node (type: ${r.type})`);const o=r;return await figma.loadFontAsync(o.fontName),o.characters=String(n),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,characters:o.characters,previousContent:e.previousContent}}catch(r){throw console.error("Error updating text content:",r),new Error(`Failed to update text content: ${r.message||r}`)}}async function $e(e){return await se(e)}async function Fe(e){const t=e.nodeId||e.Node_ID,n=e.fontFamily||e.Font_Family||"Inter",r=e.fontWeight||e.Font_Weight||400,o=e.fontSize||e.Font_Size;if(!t)throw new Error("Node ID is required");try{const i=await m(t);if(!i)throw new Error(`Node not found with ID: ${t}`);if(i.type!=="TEXT")throw new Error(`Node ${t} is not a text node (type: ${i.type})`);const c=i,s=ce(r);return await figma.loadFontAsync({family:n,style:s}),c.fontName={family:n,style:s},o&&(c.fontSize=Number(o)),figma.currentPage.selection=[c],figma.viewport.scrollAndZoomIntoView([c]),{success:!0,nodeId:c.id,name:c.name,type:c.type,fontName:c.fontName,fontSize:c.fontSize}}catch(i){throw console.error("Error setting font:",i),new Error(`Failed to set font: ${i.message||i}`)}}async function ke(e){const t=e.containsText||e.Contains_Text||e.searchText,n=e.parentId||e.Parent_ID;try{let r=function(s){if(s.type==="TEXT"){const d=s;(!t||d.characters.toLowerCase().includes(t.toLowerCase()))&&i.push(d)}if("children"in s)for(const d of s.children)r(d)},o;if(n){const s=await m(n);if(!s)throw new Error(`Parent node not found with ID: ${n}`);o=s}else o=figma.currentPage;const i=[];r(o);const c=i.map(s=>({nodeId:s.id,name:s.name,text:s.characters,fontSize:s.fontSize===figma.mixed?"mixed":s.fontSize,fontName:s.fontName===figma.mixed?"mixed":s.fontName,x:s.x,y:s.y,width:s.width,height:s.height}));return{success:!0,textNodes:c,count:c.length,searchCriteria:t||"all text nodes"}}catch(r){throw console.error("Error scanning text nodes:",r),new Error(`Failed to scan text nodes: ${r.message||r}`)}}async function Re(e){let t=e.updates||e.Updates||e.textUpdates||[];if(!Array.isArray(t)||t.length===0)throw new Error("Updates array is required with nodeId and text pairs");try{const n=[];for(const o of t){const i=o.nodeId||o.Node_ID,c=o.text||o.Text||o.content;if(!i){n.push({nodeId:"unknown",name:"unknown",success:!1,error:"Node ID is required"});continue}try{const s=await m(i);if(!s){n.push({nodeId:i,name:"not found",success:!1,error:"Node not found"});continue}if(s.type!=="TEXT"){n.push({nodeId:i,name:s.name,success:!1,error:`Node is not a text node (type: ${s.type})`});continue}const d=s;d.fontName!==figma.mixed?await figma.loadFontAsync(d.fontName):(await figma.loadFontAsync({family:"Inter",style:"Regular"}),d.fontName={family:"Inter",style:"Regular"}),d.characters=c||"",n.push({nodeId:s.id,name:s.name,success:!0})}catch(s){n.push({nodeId:i,name:"unknown",success:!1,error:s.message||"Unknown error"})}}const r=n.filter(o=>o.success).length;return{success:!0,results:n,totalRequested:t.length,successCount:r,failureCount:t.length-r}}catch(n){throw console.error("Error setting multiple text contents:",n),new Error(`Failed to set multiple text contents: ${n.message||n}`)}}async function Me(e){try{const t=e.keyword||e.Keyword||e.query||e.searchQuery||e.Search_Query||"",n=await figma.listAvailableFontsAsync();let r=n;if(t){const c=t.toLowerCase();r=n.filter(s=>s.fontName.family.toLowerCase().includes(c)||s.fontName.style.toLowerCase().includes(c))}const o=r.map(c=>({family:c.fontName.family,style:c.fontName.style,fullName:`${c.fontName.family} ${c.fontName.style}`})),i=r.reduce((c,s)=>{const d=s.fontName.family;return c[d]||(c[d]=[]),c[d].push(s.fontName.style),c},{});return{success:!0,fonts:o,fontsByFamily:i,totalCount:r.length,searchQuery:t||"all fonts",availableFamilies:Object.keys(i).sort()}}catch(t){throw console.error("Error searching available fonts:",t),new Error(`Failed to search available fonts: ${t.message||t}`)}}async function Te(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required for setFillColor");let n=e.color||e.Color;if(!n&&(e.r!==void 0||e.R!==void 0)&&(n={r:e.r!==void 0?e.r:e.R||0,g:e.g!==void 0?e.g:e.G||0,b:e.b!==void 0?e.b:e.B||0,a:e.a!==void 0?e.a:e.A!==void 0?e.A:1}),!n)throw new Error("Color is required");try{const r=await m(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("fills"in r))throw new Error(`Node ${t} does not support fills`);const o=r,i=A(n);return o.fills=[i],figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,color:i.color,opacity:i.opacity}}catch(r){throw console.error("Error setting fill color:",r),new Error(`Failed to set fill color: ${r.message||r}`)}}async function Oe(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required for setStrokeColor");let n=e.color||e.Color;const r=e.strokeWeight||e.Stroke_Weight||1;if(!n&&(e.r!==void 0||e.R!==void 0)&&(n={r:e.r!==void 0?e.r:e.R||0,g:e.g!==void 0?e.g:e.G||0,b:e.b!==void 0?e.b:e.B||0,a:e.a!==void 0?e.a:e.A!==void 0?e.A:1}),!n)throw new Error("Color is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("strokes"in o))throw new Error(`Node ${t} does not support strokes`);const i=o,c=A(n);return i.strokes=[c],i.strokeWeight=Number(r),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,color:c.color,opacity:c.opacity,strokeWeight:i.strokeWeight}}catch(o){throw console.error("Error setting stroke color:",o),new Error(`Failed to set stroke color: ${o.message||o}`)}}async function Le(e){const t=e.nodeId||e.Node_ID,n=e.opacity!==void 0?e.opacity:e.Opacity;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("Opacity value is required");const r=Number(n);if(isNaN(r)||r<0||r>1)throw new Error("Opacity must be a number between 0 and 1");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("opacity"in o))throw new Error(`Node ${t} does not support opacity`);const i=o;return i.opacity=r,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,opacity:i.opacity}}catch(o){throw console.error("Error setting opacity:",o),new Error(`Failed to set opacity: ${o.message||o}`)}}async function ze(e){const t=e.nodeId||e.Node_ID,n=e.effectType||e.Effect_Type;if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Effect type is required");try{const r=await m(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("effects"in r))throw new Error(`Node ${t} does not support effects`);const o=r;let i;switch(n.toUpperCase()){case"DROP_SHADOW":i={type:"DROP_SHADOW",color:e.color?B(e.color):{r:0,g:0,b:0,a:.25},offset:{x:e.offsetX||0,y:e.offsetY||4},radius:e.radius||4,spread:e.spread||0,visible:!0,blendMode:"NORMAL"};break;case"INNER_SHADOW":i={type:"INNER_SHADOW",color:e.color?B(e.color):{r:0,g:0,b:0,a:.25},offset:{x:e.offsetX||0,y:e.offsetY||4},radius:e.radius||4,spread:e.spread||0,visible:!0,blendMode:"NORMAL"};break;case"LAYER_BLUR":i={type:"LAYER_BLUR",radius:e.radius||4,visible:!0};break;case"BACKGROUND_BLUR":i={type:"BACKGROUND_BLUR",radius:e.radius||4,visible:!0};break;default:throw new Error(`Unsupported effect type: ${n}`)}return o.effects=[...o.effects,i],figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,effectType:n,effectsCount:o.effects.length}}catch(r){throw console.error("Error applying effect:",r),new Error(`Failed to apply effect: ${r.message||r}`)}}async function Ve(e){const t=e.nodeId||e.Node_ID,n=e.radius!==void 0?e.radius:e.Radius;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("Radius value is required");const r=Number(n);if(isNaN(r)||r<0)throw new Error("Radius must be a non-negative number");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("cornerRadius"in o))throw new Error(`Node ${t} does not support corner radius`);const i=o;return i.cornerRadius=r,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,cornerRadius:i.cornerRadius}}catch(o){throw console.error("Error setting corner radius:",o),new Error(`Failed to set corner radius: ${o.message||o}`)}}async function Be(e){const t=e.nodeId||e.Node_ID,n=e.topLeft!==void 0?Number(e.topLeft):e.Top_Left_Radius,r=e.topRight!==void 0?Number(e.topRight):e.Top_Right_Radius,o=e.bottomLeft!==void 0?Number(e.bottomLeft):e.Bottom_Left_Radius,i=e.bottomRight!==void 0?Number(e.bottomRight):e.Bottom_Right_Radius;if(!t)throw new Error("Node ID is required");try{const c=await m(t);if(!c)throw new Error(`Node not found with ID: ${t}`);if(!("topLeftRadius"in c))throw new Error(`Node ${t} does not support individual corner radius`);const s=c;return n!==void 0&&(s.topLeftRadius=Number(n)),r!==void 0&&(s.topRightRadius=Number(r)),o!==void 0&&(s.bottomLeftRadius=Number(o)),i!==void 0&&(s.bottomRightRadius=Number(i)),figma.currentPage.selection=[c],figma.viewport.scrollAndZoomIntoView([c]),{success:!0,nodeId:c.id,name:c.name,type:c.type,cornerRadius:{topLeft:s.topLeftRadius,topRight:s.topRightRadius,bottomLeft:s.bottomLeftRadius,bottomRight:s.bottomRightRadius}}}catch(c){throw console.error("Error setting individual corner radius:",c),new Error(`Failed to set individual corner radius: ${c.message||c}`)}}async function We(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.width!==void 0?Number(e.width):100,o=e.height!==void 0?Number(e.height):100,i=W("Frame",e.name),c=e.parentIdForNode||e.parentId||null,s=figma.createFrame();if(s.x=t,s.y=n,s.resize(r,o),s.name=i,e.backgroundColor||e.Background_Color){const a=e.backgroundColor||e.Background_Color;s.fills=[A(a)]}if(e.layoutMode||e.Layout_Mode){const a=e.layoutMode||e.Layout_Mode;if(a==="HORIZONTAL"||a==="VERTICAL"){s.layoutMode=a,s.primaryAxisSizingMode="AUTO",s.counterAxisSizingMode="AUTO";const l=e.padding!==void 0?e.padding:10;s.paddingLeft=l,s.paddingRight=l,s.paddingTop=l,s.paddingBottom=l;const h=e.spacing!==void 0?e.spacing:10;s.itemSpacing=h}}const d=await k(s,c);return figma.currentPage.selection=[s],R(s,d)}async function Ue(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.x!==void 0?Number(e.x):0,n=e.y!==void 0?Number(e.y):0,r=e.direction||e.Direction||"HORIZONTAL",o=e.spacing!==void 0?Number(e.spacing):10,i=e.padding!==void 0?Number(e.padding):20,c=W("Auto Layout",e.name),s=e.parentIdForNode||e.parentId||null,d=figma.createFrame();d.x=t,d.y=n,d.name=c,d.layoutMode=r,d.primaryAxisSizingMode="AUTO",d.counterAxisSizingMode="AUTO",d.itemSpacing=o,d.paddingLeft=i,d.paddingRight=i,d.paddingTop=i,d.paddingBottom=i;const a=e.primaryAxisAlign||"MIN",l=e.counterAxisAlign||"MIN";a==="CENTER"?d.primaryAxisAlignItems="CENTER":a==="MAX"?d.primaryAxisAlignItems="MAX":d.primaryAxisAlignItems="MIN",l==="CENTER"?d.counterAxisAlignItems="CENTER":l==="MAX"?d.counterAxisAlignItems="MAX":d.counterAxisAlignItems="MIN",e.backgroundColor&&(d.fills=[A(e.backgroundColor)]);const h=await k(d,s);return figma.currentPage.selection=[d],G(q({},R(d,h)),{layoutMode:d.layoutMode,itemSpacing:d.itemSpacing,padding:{left:d.paddingLeft,right:d.paddingRight,top:d.paddingTop,bottom:d.paddingBottom}})}async function qe(e){const t=e.componentId||e.Component_ID,n=e.x!==void 0?Number(e.x):0,r=e.y!==void 0?Number(e.y):0,o=e.name||e.Name,i=e.parentIdForNode||e.parentId||null,c=e.componentProperties||e.properties||e.variants||{},s=e.overrides||{};if(!t)throw new Error("Component ID is required");try{const d=ee(t),a=await m(d);if(!a)throw new Error(`Component not found with ID: ${t} (normalized: ${d})`);if(a.type!=="COMPONENT"&&a.type!=="COMPONENT_SET")throw new Error(`Node ${t} is not a component (type: ${a.type})`);let l;if(a.type==="COMPONENT")l=a.createInstance();else{const y=a.defaultVariant;if(!y)throw new Error("Component set has no default variant");l=y.createInstance()}if(Object.keys(c).length>0&&l.componentProperties)try{l.setProperties(c)}catch(y){console.warn("Error setting component properties:",y)}l.x=n,l.y=r,o&&(l.name=o),Object.keys(s).length>0&&Ge(l,s);const h=await k(l,i);figma.currentPage.selection=[l],figma.viewport.scrollAndZoomIntoView([l]);const u=await l.getMainComponentAsync();return G(q({},R(l,h)),{mainComponentId:u==null?void 0:u.id,appliedProperties:c,hasOverrides:Object.keys(s).length>0})}catch(d){throw console.error("Error creating instance:",d),new Error(`Failed to create instance: ${d.message||d}`)}}function Ge(e,t){if(t.text||t.characters){const n=t.text||t.characters;for(const[r,o]of Object.entries(n)){const i=e.findOne(c=>c.id===r&&c.type==="TEXT");i&&(i.characters=o)}}if(t.fills)for(const[n,r]of Object.entries(t.fills)){const o=e.findOne(i=>i.id===n);o&&"fills"in o&&(o.fills=r)}if(t.visible)for(const[n,r]of Object.entries(t.visible)){const o=e.findOne(i=>i.id===n);o&&(o.visible=r)}}async function Xe(e){const t=e.nodeId||e.Node_ID,n=e.gridType||e.Grid_Type||"GRID",r=e.count!==void 0?Number(e.count):12,o=e.offset!==void 0?Number(e.offset):0,i=e.gutter!==void 0?Number(e.gutter):20,c=e.color||{r:1,g:0,b:0,a:.1};if(!t)throw new Error("Node ID is required");try{const s=await m(t);if(!s)throw new Error(`Node not found with ID: ${t}`);if(!("layoutGrids"in s))throw new Error(`Node ${t} does not support layout grids`);const d=s;let a;switch(n.toUpperCase()){case"COLUMNS":a={pattern:"COLUMNS",alignment:"STRETCH",count:r,offset:o,gutterSize:i,color:c,visible:!0};break;case"ROWS":a={pattern:"ROWS",alignment:"STRETCH",count:r,offset:o,gutterSize:i,color:c,visible:!0};break;case"GRID":default:a={pattern:"GRID",sectionSize:e.sectionSize||10,color:c,visible:!0};break}return d.layoutGrids=[a],figma.currentPage.selection=[s],figma.viewport.scrollAndZoomIntoView([s]),{success:!0,nodeId:s.id,name:s.name,type:s.type,layoutGrid:a}}catch(s){throw console.error("Error setting layout grid:",s),new Error(`Failed to set layout grid: ${s.message||s}`)}}async function He(e){const t=e.nodeId||e.Node_ID,n=e.layoutMode||e.Layout_Mode||e.mode;if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Layout mode is required");try{const r=await m(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("layoutMode"in r))throw new Error(`Node ${t} does not support layout mode (type: ${r.type})`);const o=r;if(n==="NONE")o.layoutMode="NONE";else if(n==="HORIZONTAL"||n==="VERTICAL")o.layoutMode=n,o.primaryAxisSizingMode==="FIXED"&&(o.primaryAxisSizingMode="AUTO"),o.counterAxisSizingMode==="FIXED"&&(o.counterAxisSizingMode="AUTO");else throw new Error(`Invalid layout mode: ${n}. Must be NONE, HORIZONTAL, or VERTICAL`);return figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,layoutMode:o.layoutMode,primaryAxisSizingMode:o.primaryAxisSizingMode,counterAxisSizingMode:o.counterAxisSizingMode}}catch(r){throw console.error("Error setting layout mode:",r),new Error(`Failed to set layout mode: ${r.message||r}`)}}async function Ze(e){const t=e.nodeId||e.Node_ID,n=e.padding!==void 0?Number(e.padding):e.Padding,r=e.paddingLeft!==void 0?Number(e.paddingLeft):e.Padding_Left,o=e.paddingRight!==void 0?Number(e.paddingRight):e.Padding_Right,i=e.paddingTop!==void 0?Number(e.paddingTop):e.Padding_Top,c=e.paddingBottom!==void 0?Number(e.paddingBottom):e.Padding_Bottom;if(!t)throw new Error("Node ID is required");try{const s=await m(t);if(!s)throw new Error(`Node not found with ID: ${t}`);if(!("paddingLeft"in s))throw new Error(`Node ${t} does not support padding (type: ${s.type})`);const d=s;return n!==void 0?(d.paddingLeft=n,d.paddingRight=n,d.paddingTop=n,d.paddingBottom=n):(r!==void 0&&(d.paddingLeft=r),o!==void 0&&(d.paddingRight=o),i!==void 0&&(d.paddingTop=i),c!==void 0&&(d.paddingBottom=c)),figma.currentPage.selection=[s],figma.viewport.scrollAndZoomIntoView([s]),{success:!0,nodeId:s.id,name:s.name,type:s.type,padding:{left:d.paddingLeft,right:d.paddingRight,top:d.paddingTop,bottom:d.paddingBottom}}}catch(s){throw console.error("Error setting padding:",s),new Error(`Failed to set padding: ${s.message||s}`)}}async function Ye(e){const t=e.nodeId||e.Node_ID,n=e.spacing!==void 0?Number(e.spacing):e.Item_Spacing!==void 0?Number(e.Item_Spacing):e.itemSpacing;if(!t)throw new Error("Node ID is required");if(n===void 0)throw new Error("Spacing value is required");try{const r=await m(t);if(!r)throw new Error(`Node not found with ID: ${t}`);if(!("itemSpacing"in r))throw new Error(`Node ${t} does not support item spacing (type: ${r.type})`);const o=r;if(o.layoutMode==="NONE")throw new Error(`Node ${t} must have auto-layout enabled to set item spacing`);return o.itemSpacing=Number(n),figma.currentPage.selection=[r],figma.viewport.scrollAndZoomIntoView([r]),{success:!0,nodeId:r.id,name:r.name,type:r.type,itemSpacing:o.itemSpacing,layoutMode:o.layoutMode}}catch(r){throw console.error("Error setting item spacing:",r),new Error(`Failed to set item spacing: ${r.message||r}`)}}async function je(e){if(figma.editorType!=="figma")throw new Error("Component creation is only available in Design mode");let t=e.nodeIds||[];if(typeof t=="string"&&(t=t.split(",").map(o=>o.trim()).filter(o=>o.length>0)),Array.isArray(t)||(t=[t]),!t||t.length===0)throw new Error("At least one node ID is required to create a component");const n=e.name||e.Name||"Component",r=e.description||e.Description||"";try{const o=[];for(const c of t){const s=ee(c),d=await m(s);if(!d)throw new Error(`Node not found with ID: ${c} (normalized: ${s})`);o.push(d)}for(const c of o)if(!("x"in c&&"y"in c))throw new Error(`Node ${c.id} (${c.type}) cannot be converted to component`);let i;if(o.length===1){const c=o[0];if(c.type==="FRAME"||c.type==="GROUP"||c.type==="COMPONENT"||c.type==="INSTANCE"){if(i=figma.createComponentFromNode(c),!i)throw new Error("Failed to create component from node")}else{const s=figma.createFrame(),d={x:c.x,y:c.y,width:"width"in c?c.width:100,height:"height"in c?c.height:100};s.x=d.x,s.y=d.y,s.resize(d.width,d.height),s.name=n;const a=c.parent;if(a&&"appendChild"in a&&a.appendChild(s),c.x=0,c.y=0,s.appendChild(c),i=figma.createComponentFromNode(s),!i)throw new Error("Failed to create component from frame")}}else{let c=1/0,s=1/0,d=-1/0,a=-1/0;for(const f of o)c=Math.min(c,f.x),s=Math.min(s,f.y),"width"in f&&"height"in f&&(d=Math.max(d,f.x+f.width),a=Math.max(a,f.y+f.height));const l=d-c,h=a-s,u=figma.createFrame();u.x=c,u.y=s,u.resize(l,h),u.name=n;const y=o[0].parent;y&&"appendChild"in y&&y.appendChild(u);for(const f of o){const w=f.x-c,g=f.y-s;u.appendChild(f),f.x=w,f.y=g}if(i=figma.createComponentFromNode(u),!i)throw new Error("Failed to create component from frame")}return i.name=n,r&&(i.description=r),figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),{success:!0,nodeId:i.id,name:i.name,type:i.type,componentId:i.id,key:i.key,childrenCount:"children"in i?i.children.length:0,x:i.x,y:i.y,width:i.width,height:i.height}}catch(o){throw console.error("Error creating component from nodes:",o),new Error(`Failed to create component from nodes: ${o.message||o}`)}}async function Je(e){const t=e.nodeId||e.Node_ID,n=e.primaryAlign||e.Primary_Align,r=e.counterAlign||e.Counter_Align;if(!t)throw new Error("Node ID is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("layoutMode"in o))throw new Error(`Node ${t} does not support layout alignment (type: ${o.type})`);const i=o;if(i.layoutMode==="NONE")throw new Error(`Node ${t} must have auto-layout enabled to set axis alignment`);if(n){const c=n.toUpperCase();if(["MIN","CENTER","MAX","SPACE_BETWEEN"].includes(c))i.primaryAxisAlignItems=c;else throw new Error(`Invalid primary align value: ${n}. Must be MIN, CENTER, MAX, or SPACE_BETWEEN`)}if(r){const c=r.toUpperCase();if(["MIN","CENTER","MAX"].includes(c))i.counterAxisAlignItems=c;else throw new Error(`Invalid counter align value: ${r}. Must be MIN, CENTER, or MAX`)}return figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,layoutMode:i.layoutMode,primaryAxisAlignItems:i.primaryAxisAlignItems,counterAxisAlignItems:i.counterAxisAlignItems}}catch(o){throw console.error("Error setting axis alignment:",o),new Error(`Failed to set axis alignment: ${o.message||o}`)}}async function Qe(e){const t=e.nodeId||e.Node_ID,n=e.primarySizing||e.Primary_Sizing,r=e.counterSizing||e.Counter_Sizing;if(!t)throw new Error("Node ID is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("layoutMode"in o))throw new Error(`Node ${t} does not support layout sizing (type: ${o.type})`);const i=o;if(i.layoutMode==="NONE")throw new Error(`Node ${t} must have auto-layout enabled to set layout sizing`);if(n){const c=n.toUpperCase();if(["FIXED","AUTO"].includes(c))i.primaryAxisSizingMode=c;else throw new Error(`Invalid primary sizing value: ${n}. Must be FIXED or AUTO`)}if(r){const c=r.toUpperCase();if(["FIXED","AUTO"].includes(c))i.counterAxisSizingMode=c;else throw new Error(`Invalid counter sizing value: ${r}. Must be FIXED or AUTO`)}return figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,layoutMode:i.layoutMode,primaryAxisSizingMode:i.primaryAxisSizingMode,counterAxisSizingMode:i.counterAxisSizingMode}}catch(o){throw console.error("Error setting layout sizing:",o),new Error(`Failed to set layout sizing: ${o.message||o}`)}}async function Ke(e){const t=e.nodeId||e.Node_ID,n=e.annotation||e.Annotation||e.text,r=e.type||e.Type||"NOTE";if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Annotation text is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);const i={type:r,text:n,timestamp:new Date().toISOString()};let c=!1;if("description"in o)try{const s=o.description||"",d=`[${r}] ${n}`;s?o.description=`${s}
${d}`:o.description=d,c=!0}catch(s){console.warn("Failed to set description:",s)}try{const s=o.getPluginData("figmation-annotations");let d=[];if(s)try{d=JSON.parse(s)}catch(a){console.warn("Failed to parse existing annotation data:",a)}d.push(i),o.setPluginData("figmation-annotations",JSON.stringify(d))}catch(s){console.warn("Failed to store annotation as plugin data:",s)}return figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,annotation:i,storedAsDescription:c,storedAsPluginData:!0,description:"description"in o?o.description:void 0}}catch(o){throw console.error("Error setting annotation:",o),new Error(`Failed to set annotation: ${o.message||o}`)}}async function et(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r={success:!0,nodeId:n.id,name:n.name,type:n.type,annotations:[],description:null};try{const o=n.getPluginData("figmation-annotations");o&&(r.annotations=JSON.parse(o))}catch(o){console.warn("Failed to get plugin data annotations:",o)}return"description"in n&&(r.description=n.description||null),r}catch(n){throw console.error("Error getting annotations:",n),new Error(`Failed to get annotations: ${n.message||n}`)}}async function tt(e){const t=e.nodeId||e.Node_ID,n=e.x!==void 0?Number(e.x):e.X,r=e.y!==void 0?Number(e.y):e.Y,o=e.deltaX!==void 0?Number(e.deltaX):e.Delta_X,i=e.deltaY!==void 0?Number(e.deltaY):e.Delta_Y;if(!t)throw new Error("Node ID is required");try{const c=await m(t);if(!c)throw new Error(`Node not found with ID: ${t}`);if(!("x"in c&&"y"in c))throw new Error(`Node ${t} cannot be moved (not a scene node)`);const s=c;return n!==void 0?s.x=Number(n):o!==void 0&&(s.x+=Number(o)),r!==void 0?s.y=Number(r):i!==void 0&&(s.y+=Number(i)),figma.currentPage.selection=[c],figma.viewport.scrollAndZoomIntoView([c]),{success:!0,nodeId:c.id,name:c.name,type:c.type,x:s.x,y:s.y}}catch(c){throw console.error("Error moving node:",c),new Error(`Failed to move node: ${c.message||c}`)}}async function ot(e){const t=e.nodeId||e.Node_ID,n=e.width!==void 0?Number(e.width):e.Width,r=e.height!==void 0?Number(e.height):e.Height;if(!t)throw new Error("Node ID is required");if(n===void 0&&r===void 0)throw new Error("At least one dimension (width or height) is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("width"in o&&"height"in o&&"resize"in o))throw new Error(`Node ${t} cannot be resized`);const i=o,c=n!==void 0?Number(n):i.width,s=r!==void 0?Number(r):i.height;return i.resize(c,s),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,width:i.width,height:i.height}}catch(o){throw console.error("Error resizing node:",o),new Error(`Failed to resize node: ${o.message||o}`)}}async function de(e){const t=e.nodeId||e.Node_ID,n=e.angle!==void 0?Number(e.angle):e.Angle,r=e.delta!==void 0?Number(e.delta):e.Delta;if(!t)throw new Error("Node ID is required");if(n===void 0&&r===void 0)throw new Error("Either angle or delta is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("rotation"in o))throw new Error(`Node ${t} cannot be rotated`);const i=o;return n!==void 0?i.rotation=Number(n):r!==void 0&&(i.rotation=(i.rotation||0)+Number(r)),figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,rotation:i.rotation}}catch(o){throw console.error("Error rotating node:",o),new Error(`Failed to rotate node: ${o.message||o}`)}}async function nt(e){const t=G(q({},e),{angle:e.rotation!==void 0?e.rotation:e.Rotation!==void 0?e.Rotation:e.angle});return await de(t)}async function rt(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r={id:n.id,name:n.name,type:n.type};return n.remove(),{success:!0,nodeId:r.id,name:r.name,type:r.type,deleted:!0}}catch(n){throw console.error("Error deleting node:",n),new Error(`Failed to delete node: ${n.message||n}`)}}async function it(e){const t=e.nodeId||e.Node_ID,n=e.offsetX!==void 0?Number(e.offsetX):20,r=e.offsetY!==void 0?Number(e.offsetY):20;if(!t)throw new Error("Node ID is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("clone"in o))throw new Error(`Node ${t} cannot be cloned`);const c=o.clone();return"x"in c&&"y"in c&&(c.x=c.x+n,c.y=c.y+r),c.name=`${o.name} (Copy)`,figma.currentPage.selection=[c],figma.viewport.scrollAndZoomIntoView([c]),{success:!0,nodeId:c.id,name:c.name,type:c.type,x:"x"in c?c.x:0,y:"y"in c?c.y:0,originalNodeId:o.id}}catch(o){throw console.error("Error cloning node:",o),new Error(`Failed to clone node: ${o.message||o}`)}}async function oe(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];const n=e.name||e.Name||e.groupName||e.Group_Name||"Group",r=e.parentId||e.Parent_Node_ID||e.parent_node_id||null;if(typeof t=="string"&&(t=t.split(",").map(o=>o.trim()).filter(o=>o.length>0)),console.log("groupNodes received params:",JSON.stringify(e,null,2)),console.log("Parsed nodeIds:",t),console.log("Group name:",n),!Array.isArray(t)||t.length===0)throw new Error("Node IDs array is required");try{const o=[];for(const s of t){const d=await m(s);if(!d)throw new Error(`Node not found with ID: ${s}`);if(!H(d))throw new Error(`Node '${s}' cannot be grouped (not a valid scene node type)`);o.push(d)}const i=figma.group(o,figma.currentPage);i.name=n;let c=figma.currentPage.id;if(r)try{const s=await m(r);s&&"appendChild"in s?(s.appendChild(i),c=s.id,console.log(`Group moved to parent: ${s.name} (${r})`)):console.warn(`Parent node ${r} cannot contain children, keeping in current page`)}catch(s){console.warn(`Failed to move group to parent ${r}:`,s)}return figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),{success:!0,nodeId:i.id,name:i.name,type:i.type,parentId:c,childrenCount:i.children.length,groupedNodeIds:t}}catch(o){throw console.error("Error grouping nodes:",o),new Error(`Failed to group nodes: ${o.message||o}`)}}async function ct(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);if(n.type!=="GROUP")throw new Error(`Node ${t} is not a group (type: ${n.type})`);const r=n,o=r.children.map(c=>c.id),i=r.parent;return figma.ungroup(r),{success:!0,nodeId:t,ungrouped:!0,childrenIds:o,parentId:(i==null?void 0:i.id)||null}}catch(n){throw console.error("Error ungrouping node:",n),new Error(`Failed to ungroup node: ${n.message||n}`)}}async function st(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];const n=e.scrollIntoView!==void 0?e.scrollIntoView:!0;if(typeof t=="string"&&(t=t.split(",").map(r=>r.trim()).filter(r=>r.length>0)),Array.isArray(t)||(t=[t]),!t||t.length===0)throw new Error("At least one node ID is required");try{const r=[],o=[];for(const i of t)try{const c=await m(i);if(!c){o.push({id:i,error:"Node not found"});continue}if(!H(c)){o.push({id:i,error:"Node cannot be selected (not a scene node)"});continue}let s=c.parent,d=!1;for(;s;){if(s.id===figma.currentPage.id){d=!0;break}s=s.parent}if(!d){o.push({id:i,error:"Node is not on the current page"});continue}r.push(c)}catch(c){o.push({id:i,error:c.message||"Unknown error"})}return figma.currentPage.selection=r,n&&r.length>0&&figma.viewport.scrollAndZoomIntoView(r),{success:!0,selectedNodes:r.map(i=>({id:i.id,name:i.name,type:i.type})),selectedCount:r.length,errors:o.length>0?o:void 0,totalRequested:t.length}}catch(r){throw console.error("Error selecting nodes:",r),new Error(`Failed to select nodes: ${r.message||r}`)}}async function dt(e){const t=e.nodeType||e.Node_Type||e.type,n=e.parentId||e.Parent_ID,r=e.scrollIntoView!==void 0?e.scrollIntoView:!0;if(!t)throw new Error("Node type is required");try{let o=function(s){if(s.type===t.toUpperCase()&&H(s)&&c.push(s),"children"in s)for(const d of s.children)o(d)},i;if(n){const s=await m(n);if(!s)throw new Error(`Parent node not found with ID: ${n}`);i=s}else i=figma.currentPage;const c=[];return o(i),figma.currentPage.selection=c,r&&c.length>0&&figma.viewport.scrollAndZoomIntoView(c),{success:!0,selectedNodes:c.map(s=>({id:s.id,name:s.name,type:s.type})),selectedCount:c.length,nodeType:t.toUpperCase(),searchScope:n||"current page"}}catch(o){throw console.error("Error selecting nodes by type:",o),new Error(`Failed to select nodes by type: ${o.message||o}`)}}async function lt(e){const t=e.namePattern||e.Name_Pattern||e.pattern||e.name,n=e.exactMatch!==void 0?e.exactMatch:!1,r=e.caseSensitive!==void 0?e.caseSensitive:!1,o=e.parentId||e.Parent_ID,i=e.scrollIntoView!==void 0?e.scrollIntoView:!0;if(!t)throw new Error("Name pattern is required");try{let c=function(l){const h=r?l.name:l.name.toLowerCase();if((n?h===a:h.includes(a))&&H(l)&&d.push(l),"children"in l)for(const y of l.children)c(y)},s;if(o){const l=await m(o);if(!l)throw new Error(`Parent node not found with ID: ${o}`);s=l}else s=figma.currentPage;const d=[],a=r?t:t.toLowerCase();return c(s),figma.currentPage.selection=d,i&&d.length>0&&figma.viewport.scrollAndZoomIntoView(d),{success:!0,selectedNodes:d.map(l=>({id:l.id,name:l.name,type:l.type})),selectedCount:d.length,namePattern:t,exactMatch:n,caseSensitive:r,searchScope:o||"current page"}}catch(c){throw console.error("Error selecting nodes by name:",c),new Error(`Failed to select nodes by name: ${c.message||c}`)}}async function at(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(!t||!t.length)throw new Error("Node IDs are required");typeof t=="string"&&(t=t.split(",").map(n=>n.trim()).filter(n=>n.length>0)),Array.isArray(t)||(t=[t]);try{const n=[],r=[];for(const o of t)try{const i=await m(o);if(!i){r.push({id:o,error:"Node not found"});continue}n.push({id:i.id,name:i.name,type:i.type}),i.remove()}catch(i){r.push({id:o,error:i.message||"Unknown error"})}return figma.currentPage.selection=[],{success:!0,deletedNodes:n,deletedCount:n.length,errors:r.length>0?r:void 0,totalRequested:t.length}}catch(n){throw console.error("Error deleting multiple nodes:",n),new Error(`Failed to delete multiple nodes: ${n.message||n}`)}}async function ft(e){var n,r,o,i;const t=e.sourceInstanceId||e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const c=await m(t);if(!c)throw new Error(`Node not found with ID: ${t}`);if(c.type!=="INSTANCE")throw new Error(`Node ${t} is not an instance (type: ${c.type})`);const s=c,d={characters:{},fills:{},visible:{},layoutAlign:{},layoutGrow:{},constraints:{},effects:{},componentProperties:{}};async function a(y,f,w=""){if("children"in y&&"children"in f){const g=y.children,I=f.children;for(let p=0;p<g.length&&p<I.length;p++){const v=g[p],C=I[p],N=w?`${w}.${v.id}`:v.id;if(v.type==="TEXT"&&C.type==="TEXT"){const E=v,_=C;E.characters!==_.characters&&(d.characters[N]={original:_.characters,override:E.characters})}if("fills"in v&&"fills"in C){const E=JSON.stringify(v.fills),_=JSON.stringify(C.fills);E!==_&&(d.fills[N]={original:C.fills,override:v.fills})}if(v.visible!==C.visible&&(d.visible[N]={original:C.visible,override:v.visible}),"effects"in v&&"effects"in C){const E=JSON.stringify(v.effects),_=JSON.stringify(C.effects);E!==_&&(d.effects[N]={original:C.effects,override:v.effects})}if(v.type==="INSTANCE"&&C.type==="INSTANCE"){const E=v,_=C,x=await E.getMainComponentAsync(),D=await _.getMainComponentAsync();x&&D&&await a(E,x,N)}else"children"in v&&"children"in C&&await a(v,C,N)}}}s.componentProperties&&(d.componentProperties=s.componentProperties);const l=await s.getMainComponentAsync();l&&await a(s,l);const h={};for(const[y,f]of Object.entries(d))Object.keys(f).length>0&&(h[y]=f);let u={};if(l)try{if(((n=l.parent)==null?void 0:n.type)==="COMPONENT_SET"){const y=l.parent;if(y.componentPropertyDefinitions)for(const[f,w]of Object.entries(y.componentPropertyDefinitions))u[f]={type:w.type,defaultValue:w.defaultValue,variantOptions:w.variantOptions,currentValue:((r=s.componentProperties)==null?void 0:r[f])||w.defaultValue}}else if(l.type==="COMPONENT"&&((o=l.parent)==null?void 0:o.type)!=="COMPONENT_SET"&&l.componentPropertyDefinitions)for(const[y,f]of Object.entries(l.componentPropertyDefinitions))u[y]={type:f.type,defaultValue:f.defaultValue,variantOptions:f.variantOptions,currentValue:((i=s.componentProperties)==null?void 0:i[y])||f.defaultValue}}catch(y){console.warn("Error getting available properties:",y)}return{success:!0,nodeId:s.id,nodeName:s.name,nodeType:s.type,mainComponentId:l==null?void 0:l.id,mainComponentName:l==null?void 0:l.name,overrides:h,hasOverrides:Object.keys(h).length>0,availableProperties:u,componentProperties:s.componentProperties||{}}}catch(c){throw console.error("Error getting instance overrides:",c),new Error(`Failed to get instance overrides: ${c.message||c}`)}}async function ut(e){var r,o,i,c;const t=e.nodeId||e.Node_ID,n=e.overrides||e.Overrides||{};if(!t)throw new Error("Node ID is required");try{const s=await m(t);if(!s)throw new Error(`Node not found with ID: ${t}`);if(s.type!=="INSTANCE")throw new Error(`Node ${t} is not an instance (type: ${s.type})`);const d=s;let a=0,l=0,h=0;const u={},y={};if(n.componentProperties){console.log("Setting component properties:",n.componentProperties);const f=await d.getMainComponentAsync();let w={};if(f)try{if(((r=f.parent)==null?void 0:r.type)==="COMPONENT_SET"){const g=f.parent;g.componentPropertyDefinitions&&(w=g.componentPropertyDefinitions,console.log("Available properties from Component Set:",Object.keys(w)))}else f.componentPropertyDefinitions&&(w=f.componentPropertyDefinitions,console.log("Available properties from Component:",Object.keys(w)))}catch(g){console.warn("Error getting available properties for validation:",g)}for(const[g,I]of Object.entries(n.componentProperties)){h++,console.log(`Attempting to set property "${g}" to "${I}"`),Object.keys(w).length>0&&!w[g]&&console.warn(`Property "${g}" is not available in component. Available properties:`,Object.keys(w)),(o=w[g])!=null&&o.variantOptions&&!w[g].variantOptions.includes(I)&&console.warn(`Value "${I}" is not valid for property "${g}". Valid options:`,w[g].variantOptions);try{d.setProperties({[g]:I}),u[g]=I,a++,console.log(`Successfully set property "${g}" to "${I}"`)}catch(p){console.error(`Failed to set property "${g}" to "${I}":`,p),console.error("Error details:",{message:p.message,stack:p.stack,propertyType:(i=w[g])==null?void 0:i.type,expectedOptions:(c=w[g])==null?void 0:c.variantOptions})}}}return figma.currentPage.selection=[d],figma.viewport.scrollAndZoomIntoView([d]),{success:!0,nodeId:d.id,nodeName:d.name,nodeType:d.type,componentPropertiesApplied:a,totalRequested:h,appliedProperties:u,message:a>0?`Successfully applied ${a} component properties.`:"No component properties were applied."}}catch(s){throw console.error("Error setting instance overrides:",s),new Error(`Failed to set instance overrides: ${s.message||s}`)}}async function gt(e){const t=e.nodeId||e.Node_ID||e.instanceId;if(!t)throw new Error("Node ID is required");try{const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);if(n.type!=="INSTANCE")throw new Error(`Node ${t} is not an instance (type: ${n.type})`);const r=n,o=await r.getMainComponentAsync(),i=o?{id:o.id,name:o.name,key:o.key}:null,c={id:r.id,name:r.name,x:r.x,y:r.y,width:r.width,height:r.height,componentProperties:r.componentProperties||{}},s=r.detachInstance();if(!s)throw new Error("Failed to detach instance - detachInstance returned null");return figma.currentPage.selection=[s],figma.viewport.scrollAndZoomIntoView([s]),{success:!0,nodeId:s.id,name:s.name,type:s.type,x:"x"in s?s.x:0,y:"y"in s?s.y:0,width:"width"in s?s.width:0,height:"height"in s?s.height:0,wasInstance:!0,originalInstanceId:c.id,mainComponent:i,detachedFrom:(i==null?void 0:i.name)||"Unknown Component",message:`Successfully detached instance from component: ${(i==null?void 0:i.name)||"Unknown"}`}}catch(n){throw console.error("Error detaching instance:",n),new Error(`Failed to detach instance: ${n.message||n}`)}}async function ht(e){const t=(e==null?void 0:e.svgContent)||(e==null?void 0:e.SVG_Content)||(e==null?void 0:e.svg_content),n=(e==null?void 0:e.x)||(e==null?void 0:e.X)||0,r=(e==null?void 0:e.y)||(e==null?void 0:e.Y)||0,o=(e==null?void 0:e.name)||(e==null?void 0:e.Name)||"Design",i=(e==null?void 0:e.parentId)||(e==null?void 0:e.Parent_Node_ID)||(e==null?void 0:e.parentIdForNode);if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");if(!t)throw new Error("SVG content is required");function c(a){let l=100,h=100;try{const u=a.match(/viewBox="([^"]+)"/i);if(u){const w=u[1].split(/\s+/);if(w.length>=4)return l=parseFloat(w[2]),h=parseFloat(w[3]),console.log(`Extracted dimensions from viewBox: ${l}x${h}`),{width:l,height:h}}const y=a.match(/<svg[^>]+width="([^"]+)"/i),f=a.match(/<svg[^>]+height="([^"]+)"/i);if(y&&f){const w=y[1],g=f[1],I=parseFloat(w.replace(/[^\d.]/g,"")),p=parseFloat(g.replace(/[^\d.]/g,""));if(!isNaN(I)&&!isNaN(p))return l=I,h=p,console.log(`Extracted dimensions from width/height attributes: ${l}x${h}`),{width:l,height:h}}console.log(`No valid dimensions found in SVG, using default: ${l}x${h}`)}catch(u){console.warn("Error extracting SVG dimensions:",u)}return{width:l,height:h}}const{width:s,height:d}=c(t);console.log("createDesignFromSvg params received:",JSON.stringify(e,null,2)),console.log("Extracted values:",{svgContent:t?`${t.substring(0,100)}...`:null,x:n,y:r,width:s,height:d,name:o,parentId:i});try{console.log("Creating design from SVG with params:",{svgContent:t==null?void 0:t.substring(0,100),width:s,height:d}),console.log("Using figma.createNodeFromSvg with SVG content");try{const u=figma.createNodeFromSvg(t);if(u){if(u.x=n,u.y=r,u.name=o,s&&d&&u.width&&u.height){const f=s/u.width,w=d/u.height,g=Math.min(f,w);u.resize(u.width*g,u.height*g)}const y=await k(u,i);return figma.currentPage.selection=[u],figma.viewport.scrollAndZoomIntoView([u]),console.log("Successfully created SVG using figma.createNodeFromSvg"),G(q({},R(u,y)),{success:!0})}}catch(u){console.log("figma.createNodeFromSvg failed, falling back to manual parsing:",u.message)}const a=figma.createFrame();a.name=o,a.x=n,a.y=r,a.resize(s,d),a.fills=[],a.clipsContent=!1,console.log("Parsing SVG content for geometric elements");async function l(u,y,f=null){const w=u.match(/<circle[^>]+>/g);w&&(console.log("Found circles:",w.length),w.forEach((N,E)=>{const _=N.match(/cx="([^"]+)"/),x=N.match(/cy="([^"]+)"/),D=N.match(/r="([^"]+)"/),M=N.match(/fill="([^"]+)"/);if(_&&x&&D){const T=parseFloat(_[1]),F=parseFloat(x[1]),b=parseFloat(D[1]),P=M?M[1]:"#000000",S=figma.createEllipse();if(S.name=`Circle ${E+1}`,S.resize(b*2,b*2),S.x=T-b,S.y=F-b,P!=="none"){const V=ie(P);S.fills=[{type:"SOLID",color:V}]}y.appendChild(S),console.log(`Created circle at (${T}, ${F}) with radius ${b}`)}}));const g=u.match(/<rect[^>]+>/g);g&&(console.log("Found rectangles:",g.length),g.forEach((N,E)=>{const _=N.match(/x="([^"]+)"/),x=N.match(/y="([^"]+)"/),D=N.match(/width="([^"]+)"/),M=N.match(/height="([^"]+)"/),T=N.match(/fill="([^"]+)"/),F=N.match(/rx="([^"]+)"/),b=N.match(/stroke="([^"]+)"/),P=N.match(/stroke-width="([^"]+)"/);if(D&&M){const S=_?parseFloat(_[1]):0,V=x?parseFloat(x[1]):0,z=parseFloat(D[1]),X=parseFloat(M[1]),Q=T?T[1]:"#000000",Y=F?parseFloat(F[1]):0,O=figma.createRectangle();if(O.name=`Rectangle ${E+1}`,O.x=S,O.y=V,O.resize(z,X),Y>0&&(O.cornerRadius=Y),Q!=="none"&&!Q.includes("url(")){const j=B(Q);O.fills=[{type:"SOLID",color:j}]}else O.fills=[];if(b&&b[1]!=="none"){const j=B(b[1]),$=P?parseFloat(P[1]):1;O.strokes=[{type:"SOLID",color:j}],O.strokeWeight=$}y.appendChild(O),console.log(`Created rectangle at (${S}, ${V}) with size ${z}x${X}`)}}));const I=u.match(/<ellipse[^>]+>/g);I&&(console.log("Found ellipses:",I.length),I.forEach((N,E)=>{const _=N.match(/cx="([^"]+)"/),x=N.match(/cy="([^"]+)"/),D=N.match(/rx="([^"]+)"/),M=N.match(/ry="([^"]+)"/),T=N.match(/fill="([^"]+)"/);if(_&&x&&D&&M){const F=parseFloat(_[1]),b=parseFloat(x[1]),P=parseFloat(D[1]),S=parseFloat(M[1]),V=T?T[1]:"#000000",z=figma.createEllipse();if(z.name=`Ellipse ${E+1}`,z.resize(P*2,S*2),z.x=F-P,z.y=b-S,V!=="none"&&!V.includes("url(")){const X=B(V);z.fills=[{type:"SOLID",color:X}]}y.appendChild(z),console.log(`Created ellipse at (${F}, ${b}) with radii ${P}x${S}`)}}));const p=u.match(/<text[^>]*>([^<]*)<\/text>/g);if(p){console.log("Found text elements:",p.length);for(let N=0;N<p.length;N++){const E=p[N],_=E.match(/x="([^"]+)"/),x=E.match(/y="([^"]+)"/),D=E.match(/font-size="([^"]+)"/),M=E.match(/font-family="([^"]+)"/),T=E.match(/font-weight="([^"]+)"/),F=E.match(/fill="([^"]+)"/),b=E.match(/text-anchor="([^"]+)"/),P=E.match(/>([^<]+)</);if(_&&x&&P){const S=parseFloat(_[1]),V=parseFloat(x[1]),z=P[1].trim(),X=D?parseFloat(D[1]):16,Q=M?M[1].split(",")[0].replace(/['"]/g,""):"Inter",Y=T?parseInt(T[1]):400,O=F?F[1]:"#000000",j=b?b[1]:"start";try{const $=figma.createText();$.name=`Text ${N+1}`;let J="Regular";if(Y>=700?J="Bold":Y>=600?J="Semi Bold":Y>=500&&(J="Medium"),await figma.loadFontAsync({family:"Inter",style:J}),$.fontName={family:"Inter",style:J},$.fontSize=X,$.characters=z,O!=="none"&&!O.includes("url(")){const ye=B(O);$.fills=[{type:"SOLID",color:ye}]}j==="middle"?$.x=S-$.width/2:j==="end"?$.x=S-$.width:$.x=S,$.y=V-X,y.appendChild($),console.log(`Created text "${z}" at (${S}, ${V}) with size ${X}`)}catch($){console.warn(`Failed to create text ${N+1}:`,$.message)}}}}const v=u.match(/<path[^>]+d="([^"]+)"[^>]*>/g);v&&(console.log("Found paths:",v.length),v.forEach((N,E)=>{const _=N.match(/d="([^"]+)"/),x=N.match(/fill="([^"]+)"/),D=N.match(/stroke="([^"]+)"/),M=N.match(/stroke-width="([^"]+)"/);if(_){const T=_[1],F=x?x[1]:"#000000";try{const b=figma.createVector();if(b.name=`Path ${E+1}`,b.vectorPaths=[{windingRule:"NONZERO",data:T}],F!=="none"&&!F.includes("url(")){const P=B(F);b.fills=[{type:"SOLID",color:P}]}if(D&&D[1]!=="none"){const P=B(D[1]),S=M?parseFloat(M[1]):1;b.strokes=[{type:"SOLID",color:P}],b.strokeWeight=S}y.appendChild(b),console.log(`Created path vector: ${T.substring(0,50)}...`)}catch(b){console.warn(`Failed to create path ${E+1}:`,b.message)}}}));const C=u.match(/<g[^>]*>([\s\S]*?)<\/g>/g);if(C){console.log("Found groups:",C.length);for(const N of C){const E=N.match(/<g[^>]*>([\s\S]*?)<\/g>/);if(E){const _=E[1],x=figma.createFrame();x.name="Group",x.fills=[],x.clipsContent=!1,y.appendChild(x),await l(_,x)}}}}if(await l(t,a),a.children.length>0)console.log(`Successfully created ${a.children.length} SVG elements`);else throw new Error("Could not extract any valid elements from SVG content. No circles or paths found.");const h=await k(a,i);return figma.currentPage.selection=[a],figma.viewport.scrollAndZoomIntoView([a]),G(q({},R(a,h)),{svgContent:t||null,components:{container:a.id,elementsCreated:a.children.length}})}catch(a){throw console.error("Error creating design from SVG:",a),new Error(`Failed to create design from SVG: ${a.message||a}`)}}function le(e){const t=e.replace(/^data:image\/[^;]+;base64,/,""),n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r={};for(let l=0;l<n.length;l++)r[n[l]]=l;const o=t.replace(/[^A-Za-z0-9+/=]/g,""),i=o.length;let c=Math.floor(i*.75),s=0;o.endsWith("==")?s=2:o.endsWith("=")&&(s=1),c-=s;const d=new Uint8Array(c);let a=0;for(let l=0;l<i;l+=4){const h=o[l]||"A",u=o[l+1]||"A",y=o[l+2]||"=",f=o[l+3]||"=",w=r[h]||0,g=r[u]||0,I=y==="="?0:r[y]||0,p=f==="="?0:r[f]||0;a<c&&(d[a++]=w<<2|g>>4),a<c&&y!=="="&&(d[a++]=(g&15)<<4|I>>2),a<c&&f!=="="&&(d[a++]=(I&3)<<6|p&63)}return d}async function yt(e){if(figma.editorType!=="figma")throw new Error("Node creation is only available in Design mode");const t=e.base64Data||e.Base64_Data||e.base64_data,n=e.mimeType||e.Mime_Type||e.mime_type||"image/png",r=e.x||e.X||e.X_Position||e.x_position||0,o=e.y||e.Y||e.Y_Position||e.y_position||0,i=e.width||e.Width||e.WIDTH||100,c=e.height||e.Height||e.HEIGHT||100,s=W("Image",e.name||e.Name||e.NAME),d=e.parentIdForNode||e.parentId||e.Parent_Node_ID||e.parent_node_id||null,a=e.cornerRadius||e.Corner_Radius||e.Image_Corner_Radius||e.image_corner_radius||0,l=e.scaleMode||e.Scale_Mode||e.scale_mode||"FILL";if(console.log("createImageFromUrl params received:",JSON.stringify(e,null,2)),console.log("Extracted values:",{base64Data:t?`${t.substring(0,50)}...`:null,mimeType:n,x:r,y:o,width:i,height:c,name:s,parentId:d,cornerRadius:a,scaleMode:l}),!t)throw new Error("Base64 image data is required");try{console.log("Step 1: Creating rectangle container");const h=figma.createRectangle();h.x=r,h.y=o,h.resize(i,c),h.name=s,a>0&&(h.cornerRadius=a),console.log("Step 2: Converting base64 to bytes"),console.log("Base64 data length:",t.length);const u=le(t);console.log("Converted bytes length:",u.length),console.log("Step 3: Creating Figma image from bytes");const y=figma.createImage(u);console.log("Image created with hash:",y.hash);const f={type:"IMAGE",scaleMode:l,imageHash:y.hash};console.log("Step 4: Applying image fill to rectangle"),h.fills=[f],console.log("Step 5: Adding to parent node");const w=await k(h,d);return console.log("Step 6: Selecting and focusing"),figma.currentPage.selection=[h],figma.viewport.scrollAndZoomIntoView([h]),console.log("Step 7: Returning result"),G(q({},R(h,w)),{imageHash:y.hash,mimeType:n,scaleMode:l})}catch(h){throw console.error("Error creating image from URL:",h),console.error("Error stack:",h.stack),new Error(`Failed to create image from URL: ${h.message||h}`)}}async function wt(e){const t=e.nodeId||e.Node_ID,n=e.base64Data||e.Base64_Data||e.base64_data,r=e.mimeType||e.Mime_Type||e.mime_type||"image/png",o=e.scaleMode||e.Scale_Mode||e.scale_mode||"FILL";if(!t)throw new Error("Node ID is required");if(!n)throw new Error("Base64 image data is required");try{const i=await m(t);if(!i)throw new Error(`Node not found with ID: ${t}`);if(!("fills"in i))throw new Error(`Node ${t} does not support fills`);const c=i,s=le(n),d=figma.createImage(s),a={type:"IMAGE",scaleMode:o,imageHash:d.hash};return c.fills=[a],figma.currentPage.selection=[i],figma.viewport.scrollAndZoomIntoView([i]),{success:!0,nodeId:i.id,name:i.name,type:i.type,imageHash:d.hash,mimeType:r,scaleMode:o}}catch(i){throw console.error("Error replacing image:",i),new Error(`Failed to replace image: ${i.message||i}`)}}async function ae(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Union";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean union");try{const r=[];for(const i of t){const c=await m(i);if(!c)throw new Error(`Node not found with ID: ${i}`);if(!H(c))throw new Error(`Node '${i}' cannot be used in boolean operations`);r.push(c)}const o=figma.union(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"UNION",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean union:",r),new Error(`Failed to create boolean union: ${r.message||r}`)}}async function fe(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Subtract";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean subtract");try{const r=[];for(const i of t){const c=await m(i);if(!c)throw new Error(`Node not found with ID: ${i}`);if(!H(c))throw new Error(`Node '${i}' cannot be used in boolean operations`);r.push(c)}const o=figma.subtract(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"SUBTRACT",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean subtract:",r),new Error(`Failed to create boolean subtract: ${r.message||r}`)}}async function ue(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Intersect";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean intersect");try{const r=[];for(const i of t){const c=await m(i);if(!c)throw new Error(`Node not found with ID: ${i}`);if(!H(c))throw new Error(`Node '${i}' cannot be used in boolean operations`);r.push(c)}const o=figma.intersect(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"INTERSECT",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean intersect:",r),new Error(`Failed to create boolean intersect: ${r.message||r}`)}}async function ge(e){const t=e.nodeIds||e.Node_IDs||[],n=e.name||e.Name||"Exclude";if(!Array.isArray(t)||t.length<2)throw new Error("At least 2 node IDs are required for boolean exclude");try{const r=[];for(const i of t){const c=await m(i);if(!c)throw new Error(`Node not found with ID: ${i}`);if(!H(c))throw new Error(`Node '${i}' cannot be used in boolean operations`);r.push(c)}const o=figma.exclude(r,figma.currentPage);return o.name=n,figma.currentPage.selection=[o],figma.viewport.scrollAndZoomIntoView([o]),{success:!0,nodeId:o.id,name:o.name,type:o.type,operation:"EXCLUDE",inputNodeIds:t}}catch(r){throw console.error("Error creating boolean exclude:",r),new Error(`Failed to create boolean exclude: ${r.message||r}`)}}async function pt(e){const t=e.operation||e.Operation||e.type;if(!t)throw new Error("Operation type is required");switch(t.toUpperCase()){case"UNION":return await ae(e);case"SUBTRACT":return await fe(e);case"INTERSECT":return await ue(e);case"EXCLUDE":return await ge(e);default:throw new Error(`Invalid boolean operation: ${t}. Must be UNION, SUBTRACT, INTERSECT, or EXCLUDE`)}}async function It(e){try{const t=figma.root.children.map(o=>({id:o.id,name:o.name,type:o.type})),n=figma.currentPage,r=figma.currentPage.selection.map(o=>({id:o.id,name:o.name,type:o.type}));return{success:!0,document:{name:figma.root.name,id:figma.root.id,type:figma.root.type},pages:t,currentPage:{id:n.id,name:n.name,type:n.type},selection:r,selectionCount:r.length,editorType:figma.editorType,totalPages:t.length}}catch(t){throw console.error("Error getting document info:",t),new Error(`Failed to get document info: ${t.message||t}`)}}async function mt(e){const t=e.nodeId||e.Node_ID;if(!t)throw new Error("Node ID is required");try{const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r={id:n.id,name:n.name,type:n.type,visible:n.visible};if("x"in n&&"y"in n&&(r.x=n.x,r.y=n.y),"width"in n&&"height"in n&&(r.width=n.width,r.height=n.height),"rotation"in n&&(r.rotation=n.rotation),"opacity"in n&&(r.opacity=n.opacity),"fills"in n&&(r.fills=n.fills),"strokes"in n&&(r.strokes=n.strokes,"strokeWeight"in n&&(r.strokeWeight=n.strokeWeight)),"cornerRadius"in n&&(r.cornerRadius=n.cornerRadius),n.type==="TEXT"){const o=n;r.characters=o.characters,r.fontSize=o.fontSize,r.fontName=o.fontName,r.textAlignHorizontal=o.textAlignHorizontal,r.textAlignVertical=o.textAlignVertical,r.letterSpacing=o.letterSpacing,r.lineHeight=o.lineHeight}if(n.type==="FRAME"){const o=n;r.layoutMode=o.layoutMode,r.itemSpacing=o.itemSpacing,r.paddingLeft=o.paddingLeft,r.paddingRight=o.paddingRight,r.paddingTop=o.paddingTop,r.paddingBottom=o.paddingBottom,r.clipsContent=o.clipsContent}if("children"in n){const o=n;r.childrenCount=o.children.length,r.children=o.children.map(i=>({id:i.id,name:i.name,type:i.type}))}return n.parent&&(r.parent={id:n.parent.id,name:n.parent.name,type:n.parent.type}),{success:!0,nodeInfo:r}}catch(n){throw console.error("Error getting node info:",n),new Error(`Failed to get node info: ${n.message||n}`)}}async function Nt(e){try{const t=figma.currentPage.selection;if(t.length===0)return{success:!0,selection:[],selectionCount:0,message:"No nodes selected"};const n=t.map(r=>{const o={id:r.id,name:r.name,type:r.type,visible:r.visible};return"x"in r&&"y"in r&&(o.x=r.x,o.y=r.y),"width"in r&&"height"in r&&(o.width=r.width,o.height=r.height),o});return{success:!0,selection:n,selectionCount:t.length,firstSelected:n[0]}}catch(t){throw console.error("Error getting selection:",t),new Error(`Failed to get selection: ${t.message||t}`)}}async function Et(e){const t=e.query||e.Query,n=e.nodeType||e.Node_Type,r=e.limit||e.Limit||50;if(!t&&!n)throw new Error("Either query or nodeType is required");try{let o=[];n?o=figma.currentPage.findAll(s=>s.type===n.toUpperCase()):o=figma.currentPage.findAll(s=>s.name.toLowerCase().includes(t.toLowerCase()));const i=o.slice(0,r);return{success:!0,searchResults:i.map(s=>{const d={id:s.id,name:s.name,type:s.type,visible:s.visible};return"x"in s&&"y"in s&&(d.x=s.x,d.y=s.y),"width"in s&&"height"in s&&(d.width=s.width,d.height=s.height),d}),totalFound:o.length,returned:i.length,query:t,nodeType:n}}catch(o){throw console.error("Error searching nodes:",o),new Error(`Failed to search nodes: ${o.message||o}`)}}async function vt(e){const t=e.pageId||e.Page_ID;try{let n;if(t){const c=await m(t);if(!c||c.type!=="PAGE")throw new Error(`Page not found with ID: ${t}`);n=c}else n=figma.currentPage;const r=n.findAll(),o=r.reduce((c,s)=>(c[s.type]=(c[s.type]||0)+1,c),{}),i=n.children.map(c=>({id:c.id,name:c.name,type:c.type,visible:c.visible}));return{success:!0,page:{id:n.id,name:n.name,type:n.type},statistics:{totalNodes:r.length,topLevelNodes:n.children.length,nodeTypes:o},topLevelNodes:i}}catch(n){throw console.error("Error getting page info:",n),new Error(`Failed to get page info: ${n.message||n}`)}}async function _t(e){const t=e.nodeId||e.Node_ID,n=e.format||e.Format||"PNG",r=e.scale||e.Scale||1;if(!t)throw new Error("Node ID is required");try{const o=await m(t);if(!o)throw new Error(`Node not found with ID: ${t}`);if(!("exportAsync"in o))throw new Error(`Node ${t} cannot be exported`);const i=o,c={format:n.toUpperCase(),constraint:{type:"SCALE",value:r}},s=await i.exportAsync(c);let d="";const a=new Uint8Array(s);for(let h=0;h<a.length;h++)d+=String.fromCharCode(a[h]);const l=btoa(d);return{success:!0,nodeId:o.id,name:o.name,type:o.type,format:n,scale:r,imageData:l,size:s.byteLength}}catch(o){throw console.error("Error exporting node as image:",o),new Error(`Failed to export node as image: ${o.message||o}`)}}async function bt(e){let t=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(!t||!t.length)throw new Error("Node IDs are required");typeof t=="string"&&(t=t.split(",").map(n=>n.trim()).filter(n=>n.length>0)),Array.isArray(t)||(t=[t]);try{const n=[],r=[];for(const o of t)try{const i=await m(o);if(!i){r.push({id:o,error:"Node not found"});continue}const c={id:i.id,name:i.name,type:i.type,visible:i.visible};if("x"in i&&"y"in i&&(c.x=i.x,c.y=i.y),"width"in i&&"height"in i&&(c.width=i.width,c.height=i.height),"rotation"in i&&(c.rotation=i.rotation),"opacity"in i&&(c.opacity=i.opacity),"fills"in i&&(c.fills=i.fills),"strokes"in i&&(c.strokes=i.strokes,"strokeWeight"in i&&(c.strokeWeight=i.strokeWeight)),i.type==="TEXT"){const s=i;c.characters=s.characters,c.fontSize=s.fontSize,c.fontName=s.fontName}i.parent&&(c.parentId=i.parent.id,c.parentName=i.parent.name,c.parentType=i.parent.type),"children"in i&&(c.childrenCount=i.children.length),n.push(c)}catch(i){r.push({id:o,error:i.message||"Unknown error"})}return{success:!0,nodes:n,foundCount:n.length,errors:r.length>0?r:void 0,totalRequested:t.length}}catch(n){throw console.error("Error getting multiple nodes info:",n),new Error(`Failed to get multiple nodes info: ${n.message||n}`)}}async function xt(e){var o,i,c;const t=e.searchLocal!==!1,n=e.searchRemote||!1,r=e.includeVariants||!1;try{const s=[];if(t){await figma.loadAllPagesAsync();const l=figma.root.findAll(h=>r?h.type==="COMPONENT"||h.type==="COMPONENT_SET":h.type==="COMPONENT");for(const h of l)if(h.type==="COMPONENT"){const u=h;let y=u,f="Unknown",w="";for(;y&&y.type!=="PAGE";)y=y.parent;y&&y.type==="PAGE"&&(f=y.name,w=y.id);const g={id:u.id,key:u.key,name:u.name,description:u.description,type:"COMPONENT",pageName:f,pageId:w,remote:!1};try{if(((o=u.parent)==null?void 0:o.type)!=="COMPONENT_SET"&&u.componentPropertyDefinitions){g.properties={};for(const[I,p]of Object.entries(u.componentPropertyDefinitions))g.properties[I]={type:p.type,defaultValue:p.defaultValue,variantOptions:p.variantOptions}}if(((i=u.parent)==null?void 0:i.type)==="COMPONENT_SET"){const I=u.parent;if(I.componentPropertyDefinitions){g.properties={},g.isVariant=!0,g.parentSetId=I.id,g.parentSetName=I.name;for(const[p,v]of Object.entries(I.componentPropertyDefinitions))g.properties[p]={type:v.type,defaultValue:v.defaultValue,variantOptions:v.variantOptions};if(u.name){g.variantProperties={};const p=u.name.split(",").map(v=>v.trim());for(const v of p){const[C,N]=v.split("=").map(E=>E.trim());C&&N&&(g.variantProperties[C]=N)}}}}}catch(I){console.warn(`Error getting properties for component ${u.id}:`,I)}s.push(g)}else if(h.type==="COMPONENT_SET"&&r){const u=h;let y=u,f="Unknown",w="";for(;y&&y.type!=="PAGE";)y=y.parent;y&&y.type==="PAGE"&&(f=y.name,w=y.id);const g={id:u.id,key:u.key,name:u.name,description:u.description,type:"COMPONENT_SET",pageName:f,pageId:w,remote:!1,defaultVariantId:(c=u.defaultVariant)==null?void 0:c.id};if(u.componentPropertyDefinitions){g.properties={};for(const[I,p]of Object.entries(u.componentPropertyDefinitions))g.properties[I]={type:p.type,defaultValue:p.defaultValue,variantOptions:p.variantOptions}}u.variantGroupProperties&&(g.variantGroupProperties=u.variantGroupProperties),s.push(g)}}n&&console.log("Remote component search is not currently supported");const d={};for(const l of s)l.pageId&&(d[l.pageId]||(d[l.pageId]={pageName:l.pageName,componentCount:0}),d[l.pageId].componentCount++);const a=figma.root.children.map(l=>({id:l.id,name:l.name,type:l.type}));return{success:!0,components:s,totalFound:s.length,searchLocal:t,searchRemote:n,includeVariants:r,pages:a,pagesSummary:d,documentName:figma.root.name}}catch(s){throw console.error("Error getting components:",s),new Error(`Failed to get components: ${s.message||s}`)}}async function Ct(e){let t=e.nodeTypes||e.Node_Types||["TEXT"];const n=e.nodeId||e.Node_ID||null,r=e.limit||e.Limit||100;typeof t=="string"&&(t=t.split(",").map(o=>o.trim().toUpperCase()).filter(o=>o.length>0)),Array.isArray(t)||(t=[t]),t=t.map(o=>o.toUpperCase());try{let o=function(a){if(t.includes(a.type)&&c.push(a),"children"in a)for(const l of a.children)o(l)},i;if(n){const a=await m(n);if(!a)throw new Error(`Node not found with ID: ${n}`);i=a}else i=figma.currentPage;const c=[];o(i);const s=c.slice(0,r);return{success:!0,nodes:s.map(a=>{const l={id:a.id,name:a.name,type:a.type,visible:a.visible};if("x"in a&&"y"in a&&(l.x=a.x,l.y=a.y),"width"in a&&"height"in a&&(l.width=a.width,l.height=a.height),a.type==="TEXT"){const h=a;l.characters=h.characters}return a.parent&&(l.parentId=a.parent.id,l.parentName=a.parent.name,l.parentType=a.parent.type),l}),totalFound:c.length,returned:s.length,nodeTypes:t,searchScope:n||"current page"}}catch(o){throw console.error("Error scanning nodes by types:",o),new Error(`Failed to scan nodes by types: ${o.message||o}`)}}async function ne(e){let t=[],n=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(typeof n=="string"&&(n=n.split(",").map(g=>g.trim()).filter(g=>g.length>0)),Array.isArray(n)||(n=[n]),n&&n.length>0){const g=[];for(const I of n)try{const p=await m(I);p&&"x"in p&&g.push(p)}catch(p){console.warn(`Node not found: ${I}`)}t=g}else t=figma.currentPage.selection;if(!t||t.length===0)throw new Error("No nodes found. Please select nodes or provide valid node IDs.");const r=e.fillColor||e.Fill_Color,o=e.strokeColor||e.Stroke_Color,i=e.strokeWeight!==void 0?Number(e.strokeWeight):e.Stroke_Weight,c=e.strokeAlign||e.Stroke_Align||"INSIDE",s=e.opacity!==void 0?Number(e.opacity):e.Opacity,d=e.cornerRadius!==void 0?Number(e.cornerRadius):e.Corner_Radius,a=e.addDropShadow||e.Add_Drop_Shadow||!1,l=e.addInnerShadow||e.Add_Inner_Shadow||!1,h=e.addBlur||e.Add_Blur||!1,u=e.blurRadius!==void 0?Number(e.blurRadius):e.Blur_Radius||4,y=[];for(const g of t){const I=[];try{if(r&&"fills"in g){const p=A(r);g.fills=[p],I.push("fillColor")}if((o||i!==void 0)&&"strokes"in g){if(o){const p=A(o);g.strokes=[p],I.push("strokeColor")}i!==void 0&&"strokeWeight"in g&&(g.strokeWeight=i,I.push("strokeWeight")),c&&"strokeAlign"in g&&(g.strokeAlign=c,I.push("strokeAlign"))}if(s!==void 0&&"opacity"in g&&(g.opacity=Math.max(0,Math.min(1,s)),I.push("opacity")),d!==void 0&&"cornerRadius"in g&&(g.cornerRadius=Math.max(0,d),I.push("cornerRadius")),"effects"in g&&(a||l||h)){const p=[...g.effects||[]];a&&(p.push({type:"DROP_SHADOW",color:{r:0,g:0,b:0,a:.25},offset:{x:0,y:4},radius:4,spread:0,visible:!0,blendMode:"NORMAL"}),I.push("dropShadow")),l&&(p.push({type:"INNER_SHADOW",color:{r:0,g:0,b:0,a:.25},offset:{x:0,y:4},radius:4,spread:0,visible:!0,blendMode:"NORMAL"}),I.push("innerShadow")),h&&(p.push({type:"LAYER_BLUR",radius:u,visible:!0}),I.push("blur")),g.effects=p}y.push({nodeId:g.id,name:g.name,type:g.type,appliedStyles:I})}catch(p){y.push({nodeId:g.id,name:g.name,type:g.type,appliedStyles:[],error:p.message||"Unknown error"})}}const f=y.filter(g=>!g.error).length,w=y.reduce((g,I)=>g+I.appliedStyles.length,0);return{success:!0,results:y,targetCount:t.length,successCount:f,failureCount:t.length-f,totalStylesApplied:w}}async function St(e){let t=[],n=e.nodeIds||e.Node_IDs||e.Node_Ids||e.nodeIdList||[];if(typeof n=="string"&&(n=n.split(",").map(f=>f.trim()).filter(f=>f.length>0)),Array.isArray(n)||(n=[n]),n&&n.length>0){const f=[];for(const w of n)try{const g=await m(w);g&&"x"in g&&f.push(g)}catch(g){console.warn(`Node not found: ${w}`)}t=f}else t=figma.currentPage.selection;if(!t||t.length===0)throw new Error("No nodes found. Please select text nodes or provide valid node IDs.");const r=e.fontSize!==void 0?Number(e.fontSize):e.Font_Size,o=e.fontFamily||e.Font_Family,i=e.fontWeight||e.Font_Weight,c=e.textColor||e.Text_Color||e.fontColor||e.Font_Color,s=e.textAlign||e.Text_Align||e.textAlignHorizontal,d=e.letterSpacing!==void 0?Number(e.letterSpacing):e.Letter_Spacing,a=e.lineHeight!==void 0?Number(e.lineHeight):e.Line_Height,l=[];for(const f of t){const w=[];try{if(f.type!=="TEXT"){l.push({nodeId:f.id,name:f.name,type:f.type,appliedStyles:[],error:"Not a text node"});continue}const g=f;if(o||i!==void 0){const I=o||(g.fontName!==figma.mixed?g.fontName.family:"Inter"),p=i?At(i):g.fontName!==figma.mixed?g.fontName.style:"Regular";try{await figma.loadFontAsync({family:I,style:p}),g.fontName={family:I,style:p},w.push("font")}catch(v){await figma.loadFontAsync({family:"Inter",style:"Regular"}),g.fontName={family:"Inter",style:"Regular"},w.push("font (fallback)")}}if(r!==void 0&&(g.fontSize=r,w.push("fontSize")),c){const I=A(c);g.fills=[I],w.push("textColor")}s&&(g.textAlignHorizontal=s,w.push("textAlign")),d!==void 0&&(g.letterSpacing={value:d,unit:"PIXELS"},w.push("letterSpacing")),a!==void 0&&(g.lineHeight={value:a,unit:"PIXELS"},w.push("lineHeight")),l.push({nodeId:f.id,name:f.name,type:f.type,appliedStyles:w})}catch(g){l.push({nodeId:f.id,name:f.name,type:f.type,appliedStyles:[],error:g.message||"Unknown error"})}}const h=l.filter(f=>!f.error).length,u=l.filter(f=>f.type==="TEXT").length,y=l.reduce((f,w)=>f+w.appliedStyles.length,0);return{success:!0,results:l,targetCount:t.length,textNodeCount:u,successCount:h,failureCount:t.length-h,totalStylesApplied:y}}function At(e){const t=typeof e=="string"?parseInt(e):e;return!t||t===400?"Regular":t>=900?"Black":t>=800?"Extra Bold":t>=700?"Bold":t>=600?"Semi Bold":t>=500?"Medium":t>=300?"Light":t>=200?"Extra Light":t>=100?"Thin":"Regular"}async function Dt(e){const t=e.nodeId,n=e.targetIndex;if(!t)throw new Error("Node ID is required");if(n===void 0||n<0)throw new Error("Valid target index is required (0 or greater)");const r=await m(t);if(!r)throw new Error(`Node not found with ID: ${t}`);const o=r.parent;if(!o||!("children"in o))throw new Error("Node parent does not support reordering");try{const i=o.children.indexOf(r);if(i===-1)throw new Error("Node not found in parent children");const c=o.children.length-1,s=Math.min(Math.max(0,n),c);return i!==s&&o.insertChild(s,r),{success:!0,nodeId:r.id,name:r.name,type:r.type,previousIndex:i,newIndex:s,message:`Moved layer from index ${i} to ${s}`}}catch(i){throw console.error("Error reordering layer:",i),new Error(`Failed to reorder layer: ${i.message||i}`)}}async function Pt(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("appendChild"in r))throw new Error("Node parent does not support reordering");try{return r.appendChild(n),{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Moved layer to front"}}catch(o){throw console.error("Error moving layer to front:",o),new Error(`Failed to move layer to front: ${o.message||o}`)}}async function $t(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("insertChild"in r))throw new Error("Node parent does not support reordering");try{return r.insertChild(0,n),{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Moved layer to back"}}catch(o){throw console.error("Error moving layer to back:",o),new Error(`Failed to move layer to back: ${o.message||o}`)}}async function Ft(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("children"in r)||!("insertChild"in r))throw new Error("Node parent does not support reordering");try{const o=r.children.indexOf(n);if(o===-1)throw new Error("Node not found in parent children");if(o===r.children.length-1)return{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Layer is already at the front"};const i=o+1;return r.insertChild(i,n),{success:!0,nodeId:n.id,name:n.name,type:n.type,previousIndex:o,newIndex:i,message:`Moved layer forward from index ${o} to ${i}`}}catch(o){throw console.error("Error moving layer forward:",o),new Error(`Failed to move layer forward: ${o.message||o}`)}}async function kt(e){const t=e.nodeId;if(!t)throw new Error("Node ID is required");const n=await m(t);if(!n)throw new Error(`Node not found with ID: ${t}`);const r=n.parent;if(!r||!("children"in r)||!("insertChild"in r))throw new Error("Node parent does not support reordering");try{const o=r.children.indexOf(n);if(o===-1)throw new Error("Node not found in parent children");if(o===0)return{success:!0,nodeId:n.id,name:n.name,type:n.type,message:"Layer is already at the back"};const i=o-1;return r.insertChild(i,n),{success:!0,nodeId:n.id,name:n.name,type:n.type,previousIndex:o,newIndex:i,message:`Moved layer backward from index ${o} to ${i}`}}catch(o){throw console.error("Error moving layer backward:",o),new Error(`Failed to move layer backward: ${o.message||o}`)}}async function Rt(e){const t=e.parentNodeId,n=e.sortOrder||"ascending",r=e.caseSensitive!==!1;let o;if(t){const i=await m(t);if(!i)throw new Error(`Parent node not found with ID: ${t}`);if(!("children"in i))throw new Error("Specified node does not support children");o=i}else o=figma.currentPage;try{const i=[...o.children];return i.sort((c,s)=>{const d=r?c.name:c.name.toLowerCase(),a=r?s.name:s.name.toLowerCase();return n==="descending"?a.localeCompare(d):d.localeCompare(a)}),i.forEach((c,s)=>{o.insertChild(s,c)}),{success:!0,parentNodeId:o.id,parentNodeName:o.name,sortedCount:i.length,sortOrder:n,caseSensitive:r,message:`Sorted ${i.length} layers by name (${n})`}}catch(i){throw console.error("Error sorting layers by name:",i),new Error(`Failed to sort layers by name: ${i.message||i}`)}}async function Mt(e){const t=e.parentNodeId,n=e.sortBy||"x",r=e.sortOrder||"ascending";let o;if(t){const i=await m(t);if(!i)throw new Error(`Parent node not found with ID: ${t}`);if(!("children"in i))throw new Error("Specified node does not support children");o=i}else o=figma.currentPage;try{const i=o.children.filter(c=>"x"in c&&"y"in c);return i.sort((c,s)=>{let d=0;switch(n){case"x":d=c.x-s.x;break;case"y":d=c.y-s.y;break;case"xy":d=c.y-s.y,d===0&&(d=c.x-s.x);break}return r==="descending"?-d:d}),i.forEach((c,s)=>{o.insertChild(s,c)}),{success:!0,parentNodeId:o.id,parentNodeName:o.name,sortedCount:i.length,totalChildren:o.children.length,sortBy:n,sortOrder:r,message:`Sorted ${i.length} positioned layers by ${n} (${r})`}}catch(i){throw console.error("Error sorting layers by position:",i),new Error(`Failed to sort layers by position: ${i.message||i}`)}}async function Tt(e){const t=e.nodeIds,n=e.startIndex||0;if(!t||!Array.isArray(t)||t.length===0)throw new Error("Node IDs array is required");try{const r=[];let o=null;for(const c of t){const s=await m(c);if(!s)throw new Error(`Node not found with ID: ${c}`);if(o){if(s.parent!==o)throw new Error("All nodes must have the same parent")}else if(o=s.parent,!o||!("children"in o))throw new Error("Node parent does not support reordering");r.push(s)}let i=Math.max(0,Math.min(n,o.children.length-r.length));for(const c of r)o.insertChild(i,c),i++;return{success:!0,reorderedCount:r.length,parentNodeId:o.id,parentNodeName:o.name,startIndex:Math.max(0,Math.min(n,o.children.length-r.length)),message:`Reordered ${r.length} layers starting at index ${i-r.length}`}}catch(r){throw console.error("Error reordering multiple layers:",r),new Error(`Failed to reorder multiple layers: ${r.message||r}`)}}const L={serverPort:3055,channelId:"hellofigma",isConnected:!1};function Ot(){figma.showUI(__html__,{width:300,height:380,themeColors:!0}),Lt(),figma.ui.onmessage=async e=>{if(!e||typeof e.type!="string"){figma.notify("Invalid message received from UI",{error:!0});return}switch(e.type){case"execute-command":Vt(e);break;case"update-settings":Bt(e);break;case"notify":if(e.message){const t={timeout:e.timeout||3e3,error:e.error||!1};figma.notify(e.message,t)}else figma.notify("Empty notification message received",{error:!0});break;case"close-plugin":try{await figma.clientStorage.setAsync("lastSession",{timestamp:new Date().toISOString(),selectionCount:figma.currentPage.selection.length}),figma.closePlugin("👋 Figmation session ended. Thanks for using Figmation!")}catch(t){console.warn("Error during plugin cleanup:",t),figma.closePlugin()}break;default:console.warn("Unknown message type received from UI:",e.type);break}}}async function Lt(){try{const e=await figma.clientStorage.getAsync("serverSettings");e&&(L.serverPort=e.serverPort||3055,L.channelId=e.channelId||"hellofigma",console.log("✅ Loaded saved settings:",e),figma.ui.postMessage({type:"settings-loaded",settings:{serverPort:L.serverPort,channelId:L.channelId}}));const t=Ee(L.serverPort,L.channelId);t.setMessageHandler(zt),t.connect(),re(),figma.on("selectionchange",re)}catch(e){console.error("❌ Plugin initialization failed:",e),figma.notify("Plugin initialization failed. Check console for details.",{error:!0})}}async function zt(e){try{if(console.log("📨 Received WebSocket message:",e),!e.command)throw new Error("No command specified in message");const t=await he(e.command,e.parameters||{}),n={command:e.command,serverId:e.serverId,result:t,timestamp:new Date().toISOString(),success:!0};figma.ui.postMessage({type:"websocket-send",data:n}),console.log("✅ Command executed successfully:",e.command)}catch(t){console.error("❌ Command execution error:",t);const n=t instanceof Error?t.message:"Unknown error occurred",r={command:e.command,serverId:e.serverId,error:n,timestamp:new Date().toISOString(),success:!1};figma.ui.postMessage({type:"websocket-send",data:r}),figma.notify(`Command failed: ${n}`,{error:!0})}}async function Vt(e){try{console.log("🔧 Executing UI command:",e.command,e.params);const t=await he(e.command,e.params||{});figma.ui.postMessage({type:"command-result",id:e.id,result:t}),console.log("✅ UI command executed successfully:",e.command)}catch(t){console.error("❌ UI command execution error:",t);const n=t instanceof Error?t.message:"Unknown error occurred";figma.ui.postMessage({type:"command-error",id:e.id,error:n})}}async function he(e,t){const r={create_rectangle:be,create_ellipse:_e,create_circle:xe,create_line:Ce,create_star:Se,create_polygon:Ae,create_vector_path:De,create_text:Pe,update_text:$e,set_text_content:se,set_font:Fe,scan_text_nodes:ke,set_multiple_text_contents:Re,search_available_fonts:Me,set_fill_color:Te,set_stroke_color:Oe,set_opacity:Le,apply_effect:ze,set_corner_radius:Ve,set_individual_corner_radius:Be,create_frame:We,create_auto_layout:Ue,create_instance:qe,create_component:je,set_layout_grid:Xe,set_layout_mode:He,set_padding:Ze,set_item_spacing:Ye,set_axis_align:Je,set_layout_sizing:Qe,set_annotation:Ke,get_annotations:et,move_node:tt,resize_node:ot,rotate_node:de,set_rotation:nt,delete_node:rt,delete_multiple_nodes:at,clone_node:it,group_nodes:oe,create_group:oe,get_instance_overrides:ft,set_instance_overrides:ut,detach_instance:gt,ungroup_node:ct,select_nodes:st,select_nodes_by_type:dt,select_nodes_by_name:lt,create_design_from_svg:ht,create_image_from_url:yt,replace_image:wt,boolean_union:ae,boolean_subtract:fe,boolean_intersect:ue,boolean_exclude:ge,create_boolean_operation:pt,get_document_info:It,get_node_info:mt,get_nodes_info:bt,get_selection:Nt,search_nodes:Et,get_page_info:vt,export_node_as_image:_t,get_components:xt,scan_nodes_by_types:Ct,apply_styles_to_selection:ne,apply_text_styles_to_selection:St,apply_styles_to_nodes:ne,reorder_layer:Dt,move_to_front:Pt,move_to_back:$t,move_forward:Ft,move_backward:kt,sort_layers_by_name:Rt,sort_layers_by_position:Mt,reorder_multiple_layers:Tt}[e];if(!r)throw new Error(`Unknown command: ${e}`);return await r(t)}async function Bt(e){try{if(e.serverPort&&(isNaN(e.serverPort)||e.serverPort<1||e.serverPort>65535))throw new Error("Invalid server port. Must be a number between 1 and 65535.");if(e.channelId&&typeof e.channelId!="string")throw new Error("Invalid channel ID. Must be a string.");e.serverPort&&(L.serverPort=parseInt(e.serverPort)),e.channelId&&(L.channelId=e.channelId.trim()),await figma.clientStorage.setAsync("serverSettings",{serverPort:L.serverPort,channelId:L.channelId,lastUpdated:new Date().toISOString()}),console.log("✅ Settings updated and saved:",{serverPort:L.serverPort,channelId:L.channelId}),figma.ui.postMessage({type:"settings-saved",settings:{serverPort:L.serverPort,channelId:L.channelId}}),figma.notify("Settings saved successfully!",{timeout:2e3})}catch(t){console.error("❌ Settings update failed:",t);const n=t instanceof Error?t.message:"Unknown error occurred";figma.ui.postMessage({type:"settings-error",error:n}),figma.notify(`Settings update failed: ${n}`,{error:!0})}}function re(){try{const e=figma.currentPage.selection,t={count:e.length,nodes:e.map(n=>({id:n.id,name:n.name,type:n.type,x:"x"in n?n.x:0,y:"y"in n?n.y:0,width:"width"in n?n.width:0,height:"height"in n?n.height:0}))};figma.ui.postMessage({type:"selection-changed",selection:t})}catch(e){console.error("Error updating selection info:",e)}}Ot();
